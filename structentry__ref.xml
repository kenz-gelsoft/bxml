<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="structentry__ref" kind="struct" language="C++" prot="public">
    <compoundname>entry_ref</compoundname>
      <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="structentry__ref_1ac7e65996d6b3ff031dd6d529e4387c08" prot="public" static="no" mutable="no">
        <type>dev_t</type>
        <definition>dev_t entry_ref::device</definition>
        <argsstring></argsstring>
        <name>device</name>
        <qualifiedname>entry_ref::device</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The device id of the storage device on which the entry resides.</para>
<para><simplesect kind="since"><para>BeOS R3 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="33" column="6" bodyfile="/boot/home/src/haiku/headers/os/storage/Entry.h" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structentry__ref_1a3cb9497db4d8f1f842dbe9ab4fe04703" prot="public" static="no" mutable="no">
        <type>ino_t</type>
        <definition>ino_t entry_ref::directory</definition>
        <argsstring></argsstring>
        <name>directory</name>
        <qualifiedname>entry_ref::directory</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The inode number of the directory in which the entry resides.</para>
<para><simplesect kind="since"><para>BeOS R3 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="34" column="6" bodyfile="/boot/home/src/haiku/headers/os/storage/Entry.h" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structentry__ref_1a1b166a335d750f337cd531c43b09d49b" prot="public" static="no" mutable="no">
        <type>char *</type>
        <definition>char * entry_ref::name</definition>
        <argsstring></argsstring>
        <name>name</name>
        <qualifiedname>entry_ref::name</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The leaf name of the entry</para>
<para><simplesect kind="since"><para>BeOS R3 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="35" column="5" bodyfile="/boot/home/src/haiku/headers/os/storage/Entry.h" bodystart="35" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="structentry__ref_1a39ba3aeac531e62b763652d472eb7966" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>entry_ref::entry_ref</definition>
        <argsstring>()</argsstring>
        <name>entry_ref</name>
        <qualifiedname>entry_ref::entry_ref</qualifiedname>
        <briefdescription>
<para>Creates an uninitialized <ref refid="structentry__ref" kindref="compound">entry_ref</ref> object. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="since"><para>BeOS R3 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="21" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structentry__ref_1a86eda326144993e27c641ae9375e4158" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>entry_ref::entry_ref</definition>
        <argsstring>(const entry_ref &amp;ref)</argsstring>
        <name>entry_ref</name>
        <qualifiedname>entry_ref::entry_ref</qualifiedname>
        <param>
          <type>const <ref refid="structentry__ref" kindref="compound">entry_ref</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Returns a copy of the passed in <ref refid="structentry__ref" kindref="compound">entry_ref</ref> object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ref</parametername>
</parameternamelist>
<parameterdescription>
<para>A reference to an <ref refid="structentry__ref" kindref="compound">entry_ref</ref> to copy.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>BeOS R3 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="24" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structentry__ref_1aca0272efd9c83fe7c277924665c94f2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>entry_ref::entry_ref</definition>
        <argsstring>(dev_t dev, ino_t dir, const char *name)</argsstring>
        <name>entry_ref</name>
        <qualifiedname>entry_ref::entry_ref</qualifiedname>
        <param>
          <type>dev_t</type>
          <declname>dev</declname>
        </param>
        <param>
          <type>ino_t</type>
          <declname>dir</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Creates an <ref refid="structentry__ref" kindref="compound">entry_ref</ref> object initialized to the given file name in the given directory on the given device. </para>
        </briefdescription>
        <detaileddescription>
<para><emphasis>name</emphasis> may refer to either a pre-existing file in the given directory, or a non-existent file. No explicit checking is done to verify validity of the given arguments, but later use of the <ref refid="structentry__ref" kindref="compound">entry_ref</ref> will fail if <computeroutput>dev</computeroutput> is not a valid device or <emphasis>dir</emphasis> is a not a directory on <computeroutput>dev</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>The <emphasis>device</emphasis> on which the entry&apos;s parent directory resides. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dir</parametername>
</parameternamelist>
<parameterdescription>
<para>The directory in which the entry resides. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The leaf name of the entry, which is not required to exist.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>BeOS R3 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="22" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structentry__ref_1a0e47f2daa48291c66c67e05e523303a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>entry_ref::~entry_ref</definition>
        <argsstring>()</argsstring>
        <name>~entry_ref</name>
        <qualifiedname>entry_ref::~entry_ref</qualifiedname>
        <briefdescription>
<para>Destroys the object and frees the storage allocated for the leaf name, if necessary. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="since"><para>BeOS R3 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="25" column="1"/>
      </memberdef>
      <memberdef kind="function" id="structentry__ref_1a191c15337dc3ea9d2d6bee9bff4854f1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool entry_ref::operator!=</definition>
        <argsstring>(const entry_ref &amp;ref) const</argsstring>
        <name>operator!=</name>
        <qualifiedname>entry_ref::operator!=</qualifiedname>
        <param>
          <type>const <ref refid="structentry__ref" kindref="compound">entry_ref</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Compares the <ref refid="structentry__ref" kindref="compound">entry_ref</ref> object with the passed in <ref refid="structentry__ref" kindref="compound">entry_ref</ref>, returning <computeroutput>true</computeroutput> if they are NOT equal. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><computeroutput>true</computeroutput> if the entry_refs are NOT equal, <computeroutput>false</computeroutput> otherwise.</para>
</simplesect>
<simplesect kind="since"><para>BeOS R3 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="30" column="5"/>
      </memberdef>
      <memberdef kind="function" id="structentry__ref_1aba8ea743e1330f8974265dff71ed6f7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structentry__ref" kindref="compound">entry_ref</ref> &amp;</type>
        <definition>entry_ref &amp; entry_ref::operator=</definition>
        <argsstring>(const entry_ref &amp;ref)</argsstring>
        <name>operator=</name>
        <qualifiedname>entry_ref::operator=</qualifiedname>
        <param>
          <type>const <ref refid="structentry__ref" kindref="compound">entry_ref</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Makes the <ref refid="structentry__ref" kindref="compound">entry_ref</ref> object a copy of the passed in <ref refid="structentry__ref" kindref="compound">entry_ref</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ref</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structentry__ref" kindref="compound">entry_ref</ref> to copy.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A pointer to the resulting <ref refid="structentry__ref" kindref="compound">entry_ref</ref> copy.</para>
</simplesect>
<simplesect kind="since"><para>BeOS R5 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="31" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structentry__ref_1aab525d740557f80a178348a201da2a1e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool entry_ref::operator==</definition>
        <argsstring>(const entry_ref &amp;ref) const</argsstring>
        <name>operator==</name>
        <qualifiedname>entry_ref::operator==</qualifiedname>
        <param>
          <type>const <ref refid="structentry__ref" kindref="compound">entry_ref</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Compares the <ref refid="structentry__ref" kindref="compound">entry_ref</ref> object with the passed in <ref refid="structentry__ref" kindref="compound">entry_ref</ref>, returning <computeroutput>true</computeroutput> if they are equal. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><computeroutput>true</computeroutput> if he entry_refs are equal, <computeroutput>false</computeroutput> otherwise.</para>
</simplesect>
<simplesect kind="since"><para>BeOS R3 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="29" column="5"/>
      </memberdef>
      <memberdef kind="function" id="structentry__ref_1a133891c3bf1cf3f41026a3d43ac466cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t entry_ref::set_name</definition>
        <argsstring>(const char *name)</argsstring>
        <name>set_name</name>
        <qualifiedname>entry_ref::set_name</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Set the <ref refid="structentry__ref" kindref="compound">entry_ref</ref>&apos;s leaf name, freeing the storage allocated for any previous name and then making a copy of the new name. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a null-terminated string containing the new name for the entry. May be <computeroutput>NULL</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>BeOS R3 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="27" column="9"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>A filesystem entry represented as a name in a concrete directory. </para>
    </briefdescription>
    <detaileddescription>
<para>entry_refs may refer to pre-existing (concrete) files, as well as non-existing (abstract) files. However, the parent directory of the file <bold>must</bold> exist.</para>
<para>The result of this dichotomy is a blending of the persistence gained by referring to entries with a reference to their internal filesystem node and the flexibility gained by referring to entries by name.</para>
<para>For example, if the directory in which the entry resides (or a directory further up in the hierarchy) is moved or renamed, the <ref refid="structentry__ref" kindref="compound">entry_ref</ref> will still refer to the correct file (whereas a pathname to the previous location of the file would now be invalid).</para>
<para>On the other hand, say that the <ref refid="structentry__ref" kindref="compound">entry_ref</ref> refers to a concrete file. If the file itself is renamed, the <ref refid="structentry__ref" kindref="compound">entry_ref</ref> now refers to an abstract file with the old name (the upside in this case is that abstract entries may be represented by entry_refs without preallocating an internal filesystem node for them).</para>
<para><simplesect kind="since"><para>BeOS R3 </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="/boot/home/src/haiku/headers/os/storage/Entry.h" line="20" column="1" bodyfile="/boot/home/src/haiku/headers/os/storage/Entry.h" bodystart="20" bodyend="36"/>
    <listofallmembers>
      <member refid="structentry__ref_1ac7e65996d6b3ff031dd6d529e4387c08" prot="public" virt="non-virtual"><scope>entry_ref</scope><name>device</name></member>
      <member refid="structentry__ref_1a3cb9497db4d8f1f842dbe9ab4fe04703" prot="public" virt="non-virtual"><scope>entry_ref</scope><name>directory</name></member>
      <member refid="structentry__ref_1a39ba3aeac531e62b763652d472eb7966" prot="public" virt="non-virtual"><scope>entry_ref</scope><name>entry_ref</name></member>
      <member refid="structentry__ref_1aca0272efd9c83fe7c277924665c94f2a" prot="public" virt="non-virtual"><scope>entry_ref</scope><name>entry_ref</name></member>
      <member refid="structentry__ref_1a86eda326144993e27c641ae9375e4158" prot="public" virt="non-virtual"><scope>entry_ref</scope><name>entry_ref</name></member>
      <member refid="structentry__ref_1a1b166a335d750f337cd531c43b09d49b" prot="public" virt="non-virtual"><scope>entry_ref</scope><name>name</name></member>
      <member refid="structentry__ref_1a191c15337dc3ea9d2d6bee9bff4854f1" prot="public" virt="non-virtual"><scope>entry_ref</scope><name>operator!=</name></member>
      <member refid="structentry__ref_1aba8ea743e1330f8974265dff71ed6f7f" prot="public" virt="non-virtual"><scope>entry_ref</scope><name>operator=</name></member>
      <member refid="structentry__ref_1aab525d740557f80a178348a201da2a1e" prot="public" virt="non-virtual"><scope>entry_ref</scope><name>operator==</name></member>
      <member refid="structentry__ref_1a133891c3bf1cf3f41026a3d43ac466cb" prot="public" virt="non-virtual"><scope>entry_ref</scope><name>set_name</name></member>
      <member refid="structentry__ref_1a0e47f2daa48291c66c67e05e523303a1" prot="public" virt="non-virtual"><scope>entry_ref</scope><name>~entry_ref</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
