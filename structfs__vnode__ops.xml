<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="structfs__vnode__ops" kind="struct" language="C++" prot="public">
    <compoundname>fs_vnode_ops</compoundname>
      <sectiondef kind="user-defined">
      <header>VNode Operations</header>
      <memberdef kind="variable" id="structfs__vnode__ops_1a5ebce4ebee27ad71016359467fb81fe7" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::lookup)(fs_volume *volume, fs_vnode *dir, const char *name, ino_t *_id)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *dir, const char *name, ino_t *_id)</argsstring>
        <name>lookup</name>
        <qualifiedname>fs_vnode_ops::lookup</qualifiedname>
        <briefdescription>
<para>Looks up the node a directory entry refers to. </para>
        </briefdescription>
        <detaileddescription>
<para>The VFS uses this hook to resolve path names to vnodes. It is used quite often and should be implemented efficiently.</para>
<para>If the parameter <emphasis>dir</emphasis> does not specify a directory, the function shall fail. It shall also fail, if it is a directory, but does not contain an entry with the given name <emphasis>name</emphasis>. Otherwise the function shall invoke <ref refid="fs__interface_8h_1a2cfcf01bba17eee0ad3f84115051b281" kindref="member">get_vnode()</ref> for the node the entry refers to and pass back the ID of the node in <emphasis>_id</emphasis>.</para>
<para>Note that a directory must contain the special entries <computeroutput>&quot;.&quot;</computeroutput> and <computeroutput>&quot;..&quot;</computeroutput>, referring to the same directory and the parent directory respectively. <ref refid="structfs__vnode__ops_1a5ebce4ebee27ad71016359467fb81fe7" kindref="member">lookup()</ref> must resolve the nodes accordingly. <computeroutput>&quot;..&quot;</computeroutput> for the root directory of the volume shall be resolved to the root directory itself.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dir</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object for the directory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the directory entry. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_id</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a pre-allocated variable the ID of the found node shall be written to. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Everything went fine. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_NOT_A_DIRECTORY</parametername>
</parameternamelist>
<parameterdescription>
<para>The given node is not a directory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_ENTRY_NOT_FOUND</parametername>
</parameternamelist>
<parameterdescription>
<para>The given directory does not contain an entry with the given name. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="118" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="118" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1ae84954a5adbbc10c39d5d64d4852748f" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::get_vnode_name)(fs_volume *volume, fs_vnode *vnode, char *buffer, size_t bufferSize)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, char *buffer, size_t bufferSize)</argsstring>
        <name>get_vnode_name</name>
        <qualifiedname>fs_vnode_ops::get_vnode_name</qualifiedname>
        <briefdescription>
<para>Return the file name of a directory vnode. </para>
        </briefdescription>
        <detaileddescription>
<para>Normally file systems don&apos;t support hard links for directories, which means that a directory can be addressed by a unique path. This hook returns the name of the directory&apos;s entry in its parent directory.</para>
<para>Note that you don&apos;t have to implement this call if it can&apos;t be easily done; it&apos;s completely optional. If you don&apos;t implement it, you&apos;ll have to export a NULL pointer for this function in the module definition. In this case, the VFS will find the name by iterating over its parent directory.</para>
<para>If invoked for a non-directory node the hook is allowed to fail.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The buffer that the name can be copied into. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bufferSize</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>You successfully copied the file name into the <emphasis>buffer</emphasis>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>other errors</parametername>
</parameternamelist>
<parameterdescription>
<para>There was some error looking up or copying the name. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="120" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="120" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a13873870794c714e5b470cf6e3e1bf22" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>fn status_t(* fs_vnode_ops::put_vnode)(fs_volume *volume, fs_vnode *vnode, bool reenter)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, bool reenter)</argsstring>
        <name>put_vnode</name>
        <qualifiedname>fs_vnode_ops::put_vnode</qualifiedname>
        <briefdescription>
<para>Deletes the private data handle associated with the specified node. </para>
        </briefdescription>
        <detaileddescription>
<para>Invoked by the VFS when it deletes the vnode for the respective node and the node is not marked removed.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>reenter</parametername>
</parameternamelist>
<parameterdescription>
<para><computeroutput>true</computeroutput> if the hook invocation has been caused by the FS itself, e.g. by invoking <ref refid="structfs__vnode__ops_1a13873870794c714e5b470cf6e3e1bf22" kindref="member">put_vnode()</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="123" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="123" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a104571b9d1b232b87ce0db208b0393e0" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::remove_vnode)(fs_volume *volume, fs_vnode *vnode, bool reenter)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, bool reenter)</argsstring>
        <name>remove_vnode</name>
        <qualifiedname>fs_vnode_ops::remove_vnode</qualifiedname>
        <briefdescription>
<para>Deletes the private data handle associated with the specified node. </para>
        </briefdescription>
        <detaileddescription>
<para>Invoked by the VFS when it deletes the vnode for the respective node and the node has been marked removed by a call to <ref refid="structfs__vnode__ops_1a104571b9d1b232b87ce0db208b0393e0" kindref="member">remove_vnode()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>reenter</parametername>
</parameternamelist>
<parameterdescription>
<para><computeroutput>true</computeroutput> if the hook invocation has been caused by the FS itself, e.g. by invoking <ref refid="structfs__vnode__ops_1a13873870794c714e5b470cf6e3e1bf22" kindref="member">put_vnode()</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="124" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="124" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>VM file access</header>
      <memberdef kind="variable" id="structfs__vnode__ops_1a5e77e519fd95be45e32050e0acfabc15" prot="public" static="no" mutable="no">
        <type>bool(*</type>
        <definition>bool(* fs_vnode_ops::can_page)(fs_volume *volume, fs_vnode *vnode, void *cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie)</argsstring>
        <name>can_page</name>
        <qualifiedname>fs_vnode_ops::can_page</qualifiedname>
        <briefdescription>
<para>Deprecated. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="127" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="127" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1ac58b1b4ff8908d84f25259df8bea572a" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::read_pages)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)</argsstring>
        <name>read_pages</name>
        <qualifiedname>fs_vnode_ops::read_pages</qualifiedname>
        <briefdescription>
<para>Deprecated. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="128" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="128" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1ac3f066c19be99f884721a279523e9b19" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::write_pages)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)</argsstring>
        <name>write_pages</name>
        <qualifiedname>fs_vnode_ops::write_pages</qualifiedname>
        <briefdescription>
<para>Deprecated. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="130" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="130" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Asynchronous I/O</header>
      <memberdef kind="variable" id="structfs__vnode__ops_1a506f223092153b00da5f67216760496c" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::io)(fs_volume *volume, fs_vnode *vnode, void *cookie, io_request *request)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, io_request *request)</argsstring>
        <name>io</name>
        <qualifiedname>fs_vnode_ops::io</qualifiedname>
        <briefdescription>
<para>TODO: Document! </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="135" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="135" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1adc95f2deb18ce46d91b0d372a7d98179" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::cancel_io)(fs_volume *volume, fs_vnode *vnode, void *cookie, io_request *request)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, io_request *request)</argsstring>
        <name>cancel_io</name>
        <qualifiedname>fs_vnode_ops::cancel_io</qualifiedname>
        <briefdescription>
<para>TODO: Document! </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="137" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="137" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Cache File Access</header>
      <memberdef kind="variable" id="structfs__vnode__ops_1ad70a0d678d291a0c800fa76eb9c7de3f" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::get_file_map)(fs_volume *volume, fs_vnode *vnode, off_t offset, size_t size, struct file_io_vec *vecs, size_t *_count)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, off_t offset, size_t size, struct file_io_vec *vecs, size_t *_count)</argsstring>
        <name>get_file_map</name>
        <qualifiedname>fs_vnode_ops::get_file_map</qualifiedname>
        <briefdescription>
<para>Fills the <emphasis>vecs</emphasis> with the extents of the file data stream. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is called only when you are using the file cache, but if you use it, its implementation is mandatory.</para>
<para>TODO: complete me </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="141" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="141" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Standard Operations</header>
      <memberdef kind="variable" id="structfs__vnode__ops_1aff6789e84faad7959cd6511a78d6cd1d" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::ioctl)(fs_volume *volume, fs_vnode *vnode, void *cookie, ulong op, void *buffer, size_t length)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, uint32 op, void *buffer, size_t length)</argsstring>
        <name>ioctl</name>
        <qualifiedname>fs_vnode_ops::ioctl</qualifiedname>
        <briefdescription>
<para>Perform file system specific operations. </para>
        </briefdescription>
        <detaileddescription>
<para>You can implement a customized API using this call. This can be extremely handy for debugging purposes. There are no obligatory operations for you to implement.</para>
<para>If you don&apos;t want to use this feature, you don&apos;t have to implement it.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The file system provided cookie associated with, for example, an open file (if applicable). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The operation code. You will have to define them yourself. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>A buffer (if applicable). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>You should return any of your status codes. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="145" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="145" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a4831dd9e1d3e99797b41d6ed147b70ad" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::set_flags)(fs_volume *volume, fs_vnode *vnode, void *cookie, int flags)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, int flags)</argsstring>
        <name>set_flags</name>
        <qualifiedname>fs_vnode_ops::set_flags</qualifiedname>
        <briefdescription>
<para>Set the open mode flags for an opened file. </para>
        </briefdescription>
        <detaileddescription>
<para>This function should change the open flags for an opened file.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The file system provided cookie associated with the opened file. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>The new flags. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if the operation succeeded, or else an error code. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="147" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="147" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a3cdcec6960aa08e7abfdd02f1c8e22d3" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::select)(fs_volume *volume, fs_vnode *vnode, void *cookie, uint8 event, selectsync *sync)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, uint8 event, selectsync *sync)</argsstring>
        <name>select</name>
        <qualifiedname>fs_vnode_ops::select</qualifiedname>
        <briefdescription>
<para>Selects the specified <emphasis>vnode</emphasis> with the specified <emphasis>events</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is called by the VFS whenever <ref refid="structfs__vnode__ops_1a3cdcec6960aa08e7abfdd02f1c8e22d3" kindref="member">select()</ref> or poll() is called on a file descriptor that points to your file system.</para>
<para>You have to check if the condition of the <ref refid="structfs__vnode__ops_1a3cdcec6960aa08e7abfdd02f1c8e22d3" kindref="member">select()</ref> (ie. if there is data available if event is B_SELECT_READ) is already satisfied, and call notify_select_event() with the <emphasis>sync</emphasis> and <emphasis>ref</emphasis> arguments you retrieve here.</para>
<para>Additionally, when a vnode is selected this way, you have to call notify_select_event() whenever the condition becomes true until the vnode is deselected again via file_system_module_info::deselect().</para>
<para>This function is optional. If you don&apos;t export it, the default implementation in the VFS will call notify_select_event() directly which will be sufficient for most file systems.</para>
<para>Note that while <ref refid="structfs__vnode__ops_1a3cdcec6960aa08e7abfdd02f1c8e22d3" kindref="member">select()</ref> and the corresponding <ref refid="structfs__vnode__ops_1af641c9244f8125d5669834a0fb7cb3bd" kindref="member">deselect()</ref> are invoked by the same thread, notifications are usually generated by other threads. It is your responsibility to make sure that notify_select_event() is never called for a selectsync object for which <ref refid="structfs__vnode__ops_1af641c9244f8125d5669834a0fb7cb3bd" kindref="member">deselect()</ref> has already returned. This is commonly done by holding the same lock when invoking notify_select_event() and when removing the selectsync object from the cookie in <ref refid="structfs__vnode__ops_1af641c9244f8125d5669834a0fb7cb3bd" kindref="member">deselect()</ref>. Such a lock can be any lock, usually one that is associated with the node or the volume.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The file system provided cookie associated with the opened file. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>event</parametername>
</parameternamelist>
<parameterdescription>
<para>The event to be selected. One of:<itemizedlist>
<listitem><para><computeroutput>B_SELECT_READ:</computeroutput> File ready for reading.</para>
</listitem><listitem><para><computeroutput>B_SELECT_WRITE:</computeroutput> File ready for writing.</para>
</listitem><listitem><para><computeroutput>B_SELECT_ERROR:</computeroutput> I/O error condition.</para>
</listitem><listitem><para><computeroutput>B_SELECT_PRI_READ:</computeroutput> File ready for priority read.</para>
</listitem><listitem><para><computeroutput>B_SELECT_PRI_WRITE:</computeroutput> File ready for priority write.</para>
</listitem><listitem><para><computeroutput>B_SELECT_HIGH_PRI_READ:</computeroutput> File ready for high priority read.</para>
</listitem><listitem><para><computeroutput>B_SELECT_HIGH_PRI_WRITE:</computeroutput> File ready for high priority write.</para>
</listitem><listitem><para><computeroutput>B_SELECT_DISCONNECTED:</computeroutput> Socket/FIFO/... has been disconnected. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sync</parametername>
</parameternamelist>
<parameterdescription>
<para>Opaque pointer to be passed to notify_select_event(). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if the operation succeeded, or else an error code. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="149" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="149" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1af641c9244f8125d5669834a0fb7cb3bd" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::deselect)(fs_volume *volume, fs_vnode *vnode, void *cookie, uint8 event, selectsync *sync)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, uint8 event, selectsync *sync)</argsstring>
        <name>deselect</name>
        <qualifiedname>fs_vnode_ops::deselect</qualifiedname>
        <briefdescription>
<para>Deselects the specified <emphasis>vnode</emphasis> from a previous <ref refid="structfs__vnode__ops_1a3cdcec6960aa08e7abfdd02f1c8e22d3" kindref="member">select()</ref> call. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is called by the VFS whenever a <ref refid="structfs__vnode__ops_1a3cdcec6960aa08e7abfdd02f1c8e22d3" kindref="member">select()</ref> or poll() function exits that previously called file_system_module_info::select() on that <emphasis>vnode</emphasis>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The file system provided cookie associated with the opened file. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>event</parametername>
</parameternamelist>
<parameterdescription>
<para>The event to be deselected. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sync</parametername>
</parameternamelist>
<parameterdescription>
<para>Opaque pointer to be passed to notify_select_event(). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if the operation succeeded, or else an error code. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="151" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="151" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a426627e06dd3c6bfbfd9565ae622fb3b" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::fsync)(fs_volume *volume, fs_vnode *vnode)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode)</argsstring>
        <name>fsync</name>
        <qualifiedname>fs_vnode_ops::fsync</qualifiedname>
        <briefdescription>
<para>Synchronize the buffers with the on disk data. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if the operation succeeded, or else an error code. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="153" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="153" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1acbf78b533817de642e1ab9c3d69797a2" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::read_symlink)(fs_volume *volume, fs_vnode *link, char *buffer, size_t *_bufferSize)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *link, char *buffer, size_t *_bufferSize)</argsstring>
        <name>read_symlink</name>
        <qualifiedname>fs_vnode_ops::read_symlink</qualifiedname>
        <briefdescription>
<para>Read the value of a symbolic link. </para>
        </briefdescription>
        <detaileddescription>
<para>If the function is successful, the symlink string shall be written to the buffer. It does not need to be null-terminated. If the buffer is too small to hold the complete string, only the first <computeroutput>*_bufferSize</computeroutput> bytes of the string shall be written to the buffer; the buffer shall not be null-terminated in this case. Furthermore the variable <emphasis>_bufferSize</emphasis> shall be set to the length of the symlink contents, even if the entire contents did not fit in the provided <emphasis>buffer</emphasis>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>link</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a pre-allocated buffer the link value shall be written to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_bufferSize</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a pre-allocated variable containing the size of the buffer supplied to the function. Upon successful completion the hook shall store the length of the symlink contents. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Everything went fine. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_BAD_VALUE</parametername>
</parameternamelist>
<parameterdescription>
<para><emphasis>link</emphasis> does not identify a symbolic link. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="155" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="155" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1aeb6d3f5493748470a7894c6e6486d324" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::create_symlink)(fs_volume *volume, fs_vnode *dir, const char *name, const char *path, int mode)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *dir, const char *name, const char *path, int mode)</argsstring>
        <name>create_symlink</name>
        <qualifiedname>fs_vnode_ops::create_symlink</qualifiedname>
        <briefdescription>
<para>Create a new symbolic link. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dir</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object for the directory the symbolic link should be created in. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the new symbolic link. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>path</parametername>
</parameternamelist>
<parameterdescription>
<para>The path the symbolic link should refer to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>The permissions for the newly created symbolic link. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if you succeeded, or an error code if you failed. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="157" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="157" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a3bb3ba7ca9d0cf2f83bdc5c4097f703a" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::link)(fs_volume *volume, fs_vnode *dir, const char *name, fs_vnode *vnode)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *dir, const char *name, fs_vnode *vnode)</argsstring>
        <name>link</name>
        <qualifiedname>fs_vnode_ops::link</qualifiedname>
        <briefdescription>
<para>Create a new hard link. </para>
        </briefdescription>
        <detaileddescription>
<para>The virtual file system will request the creation of symbolic links with <ref refid="structfs__vnode__ops_1aeb6d3f5493748470a7894c6e6486d324" kindref="member">create_symlink()</ref>.</para>
<para>If you don&apos;t implement this function, the VFS will return <computeroutput>EROFS</computeroutput> when a hard link is requested. So, if you don&apos;t support hard links implement this hook and return an appropriate error code.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dir</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object for the directory where the link should be created. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name the link should have. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The vnode the new link should resolve to. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>The hard link is properly created. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_NOT_ALLOWED</parametername>
</parameternamelist>
<parameterdescription>
<para>The user does not have the proper permissions. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>other errors</parametername>
</parameternamelist>
<parameterdescription>
<para>Another error occured. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="160" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="160" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a61236086b99dff3f53f2842349d67917" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::unlink)(fs_volume *volume, fs_vnode *dir, const char *name)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *dir, const char *name)</argsstring>
        <name>unlink</name>
        <qualifiedname>fs_vnode_ops::unlink</qualifiedname>
        <briefdescription>
<para>Remove a non-directory entry. </para>
        </briefdescription>
        <detaileddescription>
<para>Remove an entry that does refer to a non-directory node. For removing directories the <ref refid="structfs__vnode__ops_1ae91372438edbe5575432cb7fd5308d35" kindref="member">remove_dir()</ref> hook is used. If invoked on a directory, this hook shall fail.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dir</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object for the directory containing the entry to be removed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the entry that should be removed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Removal succeeded. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_ENTRY_NOT_FOUND</parametername>
</parameternamelist>
<parameterdescription>
<para>The entry does not exist. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_NOT_ALLOWED</parametername>
</parameternamelist>
<parameterdescription>
<para>The user does not have the proper permissions. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_IS_A_DIRECTORY</parametername>
</parameternamelist>
<parameterdescription>
<para>The entry refers to a directory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>other errors</parametername>
</parameternamelist>
<parameterdescription>
<para>Another error occured. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="162" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="162" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a9f492cb3f6b8576da5b9b61720382071" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::rename)(fs_volume *volume, fs_vnode *fromDir, const char *fromName, fs_vnode *toDir, const char *toName)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *fromDir, const char *fromName, fs_vnode *toDir, const char *toName)</argsstring>
        <name>rename</name>
        <qualifiedname>fs_vnode_ops::rename</qualifiedname>
        <briefdescription>
<para>Rename and/or relocate an entry. </para>
        </briefdescription>
        <detaileddescription>
<para>The virtual file system merely relays the request, so make sure the user is not changing the file name to something like &apos;.&apos;, &apos;..&apos; or anything starting with &apos;/&apos;.</para>
<para>This also means that it if the entry refers to a directory, that it should not be moved into one of its own children.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fromDir</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object for the parent directory the entry should be moved from. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fromName</parametername>
</parameternamelist>
<parameterdescription>
<para>The old entry name. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>toDir</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object for the parent directory the entry should be moved to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>toName</parametername>
</parameternamelist>
<parameterdescription>
<para>The new entry name. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>The renaming and relocating succeeded. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_BAD_VALUE</parametername>
</parameternamelist>
<parameterdescription>
<para>One of the supplied parameters were invalid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_NOT_ALLOWED</parametername>
</parameternamelist>
<parameterdescription>
<para>The user does not have the proper permissions. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>other errors</parametername>
</parameternamelist>
<parameterdescription>
<para>Another error condition was encountered. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="163" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="163" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a86ed7b682fa1006e353167845f4e7d60" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::access)(fs_volume *volume, fs_vnode *vnode, int mode)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, int mode)</argsstring>
        <name>access</name>
        <qualifiedname>fs_vnode_ops::access</qualifiedname>
        <briefdescription>
<para>Checks whether the current user is allowed to access the node in the specified way. </para>
        </briefdescription>
        <detaileddescription>
<para><emphasis>mode</emphasis> is a bitwise combination of:<itemizedlist>
<listitem><para><computeroutput>R_OK:</computeroutput> Read access.</para>
</listitem><listitem><para><computeroutput>W_OK:</computeroutput> Write access.</para>
</listitem><listitem><para><computeroutput>X_OK:</computeroutput> Execution.</para>
</listitem></itemizedlist>
</para>
<para>If the current user does not have any of the access permissions represented by the set bits, the function shall return <computeroutput>B_NOT_ALLOWED</computeroutput>. As a special case, if the volume is read-only and write access is requested, <computeroutput>B_READ_ONLY_DEVICE</computeroutput> shall be returned. If the requested access mode complies with the user&apos;s access permissions, the function shall return <computeroutput>B_OK</computeroutput>.</para>
<para>For most FSs the permissions a user has are defined by the <computeroutput>st_mode</computeroutput>, <computeroutput>st_uid</computeroutput>, and <computeroutput>st_gid</computeroutput> fields of the node&apos;s stat data. As a special exception, the root user (<computeroutput>geteuid() == 0</computeroutput>) does always have read and write permissions, execution permission only when at least one of the execution permission bits are set.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>The access mode mask. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>The user has the permissions to access the node in the requested way. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_READ_ONLY_DEVICE</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume is read-only, but the write access has been requested. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_NOT_ALLOWED</parametername>
</parameternamelist>
<parameterdescription>
<para>The user does not have all permissions to access the node in the requested way. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="166" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="166" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a645a7315d3274a84958586c543efb6b6" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::read_stat)(fs_volume *volume, fs_vnode *vnode, struct stat *stat)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, struct stat *stat)</argsstring>
        <name>read_stat</name>
        <qualifiedname>fs_vnode_ops::read_stat</qualifiedname>
        <briefdescription>
<para>Retrieves the stat data for a given node. </para>
        </briefdescription>
        <detaileddescription>
<para>All values of the <computeroutput>struct stat</computeroutput> save <computeroutput>st_dev</computeroutput>, <computeroutput>st_ino</computeroutput>, <computeroutput>st_rdev</computeroutput>, and <computeroutput>st_type</computeroutput> need to be filled in.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stat</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a pre-allocated variable the stat data shall be written to. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="167" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="167" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a1658906a3924b698a34baa2bd8757ea5" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::write_stat)(fs_volume *volume, fs_vnode *vnode, const struct stat *stat, uint32 statMask)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, const struct stat *stat, uint32 statMask)</argsstring>
        <name>write_stat</name>
        <qualifiedname>fs_vnode_ops::write_stat</qualifiedname>
        <briefdescription>
<para>Update the stats for a vnode. </para>
        </briefdescription>
        <detaileddescription>
<para>You should make sure that the new values are valid.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stat</parametername>
</parameternamelist>
<parameterdescription>
<para>The structure with the updated values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>statMask</parametername>
</parameternamelist>
<parameterdescription>
<para>A bitwise combination of one or more of the following, specifying which stat field shall be set:<itemizedlist>
<listitem><para>B_STAT_MODE: Set the node permissions.</para>
</listitem><listitem><para>B_STAT_UID: Set the owning user.</para>
</listitem><listitem><para>B_STAT_GID: Set the owner group.</para>
</listitem><listitem><para>B_STAT_SIZE: Set the size of the file. If enlarged, the file is padded. Normally with zero bytes, but with unspecified data, if B_STAT_SIZE_INSECURE is specified, too.</para>
</listitem><listitem><para>B_STAT_SIZE_INSECURE: Modifier for B_STAT_SIZE: When enlarging the file padding can be done with arbitrary data.</para>
</listitem><listitem><para>B_STAT_ACCESS_TIME: Set the access time.</para>
</listitem><listitem><para>B_STAT_MODIFICATION_TIME: Set the modification time.</para>
</listitem><listitem><para>B_STAT_CREATION_TIME: Set the creation time.</para>
</listitem><listitem><para>B_STAT_CHANGE_TIME: Set the change time. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>The update succeeded. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_NOT_ALLOWED</parametername>
</parameternamelist>
<parameterdescription>
<para>The user does not have the proper permissions. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>other errors</parametername>
</parameternamelist>
<parameterdescription>
<para>Another error condition occured. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="169" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="169" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>File Operations</header>
      <memberdef kind="variable" id="structfs__vnode__ops_1a7b09be06f0c168397d62b4348d90c245" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::create)(fs_volume *volume, fs_vnode *dir, const char *name, int openMode, int perms, void **_cookie, ino_t *_newVnodeID)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *dir, const char *name, int openMode, int perms, void **_cookie, ino_t *_newVnodeID)</argsstring>
        <name>create</name>
        <qualifiedname>fs_vnode_ops::create</qualifiedname>
        <briefdescription>
<para>Creates and opens a new file. </para>
        </briefdescription>
        <detaileddescription>
<para>The hook is similar to <ref refid="structfs__vnode__ops_1a153038dfcab23bfedaf0a3657a1bb01a" kindref="member">open() </ref>, with the difference that, if an entry with the name <emphasis>name</emphasis> does not already exist in the given directory, a new file with that name is created first. If the entry does already exist and <emphasis>openMode</emphasis> specifies the <computeroutput>O_EXCL</computeroutput> flag, the function shall fail with <computeroutput>B_FILE_EXISTS</computeroutput> (aka <computeroutput>EEXIST</computeroutput>).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dir</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object for the directory where the file should appear. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the new file. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>openMode</parametername>
</parameternamelist>
<parameterdescription>
<para>The mode associated to the file. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>perms</parametername>
</parameternamelist>
<parameterdescription>
<para>The permissions the new file should have. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">_cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>In case of success, the storage where you can put your FS specific cookie for the open node. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">_newVnodeID</parametername>
</parameternamelist>
<parameterdescription>
<para>In case of success, you can store the new vnode id in this variable. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>If opening the node succeeded (after creating it first, if necessary), <computeroutput>B_OK</computeroutput> shall be returned and <emphasis>_cookie</emphasis> and <emphasis>_newVnodeID</emphasis> shall be set. Otherwise an error code shall be returned. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="175" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="175" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a153038dfcab23bfedaf0a3657a1bb01a" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::open)(fs_volume *volume, fs_vnode *vnode, int openMode, void **_cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, int openMode, void **_cookie)</argsstring>
        <name>open</name>
        <qualifiedname>fs_vnode_ops::open</qualifiedname>
        <briefdescription>
<para>Opens the given node. </para>
        </briefdescription>
        <detaileddescription>
<para>The hook is invoked whenever a file is opened (e.g. via the <ref refid="structfs__vnode__ops_1a153038dfcab23bfedaf0a3657a1bb01a" kindref="member">open()</ref> POSIX function).</para>
<para>The hook can create a node cookie, and store it in the variable <emphasis>_cookie</emphasis> points to. The cookie will be passed to all hooks that operate on open files.</para>
<para>The open mode <emphasis>openMode</emphasis> is encoded in the same way as the parameter of the POSIX function <computeroutput><ref refid="structfs__vnode__ops_1a153038dfcab23bfedaf0a3657a1bb01a" kindref="member">open()</ref></computeroutput>, i.e. it is either <computeroutput>O_RDONLY</computeroutput>, <computeroutput>O_WRONLY</computeroutput>, or <computeroutput>O_RDWR</computeroutput>, bitwise or&apos;ed with flags. The only relevant flags for this hook are <computeroutput>O_TRUNC</computeroutput> and <computeroutput>O_NONBLOCK</computeroutput>. You will normally want to store the open mode in the file cookie, since you&apos;ll have to check in <ref refid="structfs__vnode__ops_1a3d5f1013644389c3efee43b3e175aa34" kindref="member">read()</ref> and <ref refid="structfs__vnode__ops_1a6b15bdec37363749b7dcf5e05b04d6ba" kindref="member">write()</ref> whether the the respective operation is allowed by the open mode.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>openMode</parametername>
</parameternamelist>
<parameterdescription>
<para>The open mode. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a pre-allocated variable the node cookie shall be written to. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="178" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="178" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a0be1b1f60bf8b8d39e3668051e62a138" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::close)(fs_volume *volume, fs_vnode *vnode, void *cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie)</argsstring>
        <name>close</name>
        <qualifiedname>fs_vnode_ops::close</qualifiedname>
        <briefdescription>
<para>Closes the given node cookie. </para>
        </briefdescription>
        <detaileddescription>
<para>The hook is invoked, when closing the node has been requested. At this point other threads might still use the cookie, i.e. still execute hooks to which the cookie has been passed. If the FS supports blocking I/O operations, this hook should make sure to unblock all currently blocking threads performing an operation using the cookie, and mark the cookie such that no further threads will block using it.</para>
<para>For many FSs this hook is a no-op <ndash/> it&apos;s mandatory to be exported, though.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The node cookie as returned by <ref refid="structfs__vnode__ops_1a153038dfcab23bfedaf0a3657a1bb01a" kindref="member">open()</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="180" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="180" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a86efe64fe11783e782da8054c50cebce" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::free_cookie)(fs_volume *volume, fs_vnode *vnode, void *cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie)</argsstring>
        <name>free_cookie</name>
        <qualifiedname>fs_vnode_ops::free_cookie</qualifiedname>
        <briefdescription>
<para>Frees the given node cookie. </para>
        </briefdescription>
        <detaileddescription>
<para>The hook is invoked after <ref refid="structfs__vnode__ops_1a0be1b1f60bf8b8d39e3668051e62a138" kindref="member">close()</ref>, when no other thread uses or is going to use the cookie. All resources associated with the cookie must be freed.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The node cookie as returned by <ref refid="structfs__vnode__ops_1a153038dfcab23bfedaf0a3657a1bb01a" kindref="member">open()</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="181" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="181" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a3d5f1013644389c3efee43b3e175aa34" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::read)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, void *buffer, size_t *length)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, void *buffer, size_t *length)</argsstring>
        <name>read</name>
        <qualifiedname>fs_vnode_ops::read</qualifiedname>
        <briefdescription>
<para>Reads data from a file. </para>
        </briefdescription>
        <detaileddescription>
<para>This function should fail if<itemizedlist>
<listitem><para>the node is not a file,</para>
</listitem><listitem><para>the cookie has not been opened for reading,</para>
</listitem><listitem><para><emphasis>pos</emphasis> is negative, or</para>
</listitem><listitem><para>some other error occurs while trying to read the data, and no data have been read at all.</para>
</listitem></itemizedlist>
</para>
<para>The number of bytes to be read is stored in the variable pointed to by <emphasis>length</emphasis>. If less data is available at file position <emphasis>pos</emphasis>, or if <emphasis>pos</emphasis> if greater than the size of the file, only as many data as available shall be read, the function shall store the number of bytes actually read into the variable pointed to by <emphasis>length</emphasis>, and return <computeroutput>B_OK</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The node cookie as returned by <ref refid="structfs__vnode__ops_1a153038dfcab23bfedaf0a3657a1bb01a" kindref="member">open()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>The file position where to start reading data. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a pre-allocated buffer the read data shall be written to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a pre-allocated variable containing the size of the buffer when invoked, and into which the size of the data actually read shall be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="183" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="183" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a6b15bdec37363749b7dcf5e05b04d6ba" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::write)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const void *buffer, size_t *length)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const void *buffer, size_t *length)</argsstring>
        <name>write</name>
        <qualifiedname>fs_vnode_ops::write</qualifiedname>
        <briefdescription>
<para>Write data to a file. </para>
        </briefdescription>
        <detaileddescription>
<para>This function should fail if<itemizedlist>
<listitem><para>the node is not a file,</para>
</listitem><listitem><para>the cookie has not been opened for writing,</para>
</listitem><listitem><para><emphasis>pos</emphasis> is negative, or</para>
</listitem><listitem><para>some other error occurs while trying to write the data, and no data have been written at all.</para>
</listitem></itemizedlist>
</para>
<para>The number of bytes to be written is stored in the variable pointed to by <emphasis>length</emphasis>. If not all bytes could be written, that variable must be updated to reflect the amount of actually written bytes. If any bytes have been written, the function shall not fail, if an error prevents you from writing the full amount. Only when the error prevented you from writing any data at all an error shall be returned.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The file system provided cookie associated with the file. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>The position to start writing. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The buffer that contains the data that will need to be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>The length of the data that needs to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="185" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="185" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Directory Operations</header>
      <memberdef kind="variable" id="structfs__vnode__ops_1aa3a5019b2694449020131280f46883cd" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::create_dir)(fs_volume *volume, fs_vnode *parent, const char *name, int perms)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *parent, const char *name, int perms)</argsstring>
        <name>create_dir</name>
        <qualifiedname>fs_vnode_ops::create_dir</qualifiedname>
        <briefdescription>
<para>Create a new directory. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>parent</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object for the directory in which to create the new directory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name the new directory should have. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>perms</parametername>
</parameternamelist>
<parameterdescription>
<para>The permissions the new directory should have. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if the directory was created successfully, an error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="189" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="189" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1ae91372438edbe5575432cb7fd5308d35" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::remove_dir)(fs_volume *volume, fs_vnode *parent, const char *name)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *parent, const char *name)</argsstring>
        <name>remove_dir</name>
        <qualifiedname>fs_vnode_ops::remove_dir</qualifiedname>
        <briefdescription>
<para>Remove a directory. </para>
        </briefdescription>
        <detaileddescription>
<para>The function shall fail, if the entry does not refer to a directory, or if it refers to a directory that is not empty.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>parent</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object for the parent directory containing the directory to be removed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The <emphasis>name</emphasis> of the directory that needs to be removed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Operation succeeded. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_ENTRY_NOT_FOUND</parametername>
</parameternamelist>
<parameterdescription>
<para>There is no entry with this <emphasis>name</emphasis>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_NOT_A_DIRECTORY</parametername>
</parameternamelist>
<parameterdescription>
<para>The entry is not a directory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_DIRECTORY_NOT_EMPTY</parametername>
</parameternamelist>
<parameterdescription>
<para>The directory is not empty. The virtual file system expects directories to be emptied before they can be removed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>other errors</parametername>
</parameternamelist>
<parameterdescription>
<para>Other errors occured. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="191" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="191" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a973d90db38ea724859e8a1b708ed70c8" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::open_dir)(fs_volume *volume, fs_vnode *vnode, void **_cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void **_cookie)</argsstring>
        <name>open_dir</name>
        <qualifiedname>fs_vnode_ops::open_dir</qualifiedname>
        <briefdescription>
<para>Opens the given directory node. </para>
        </briefdescription>
        <detaileddescription>
<para>If the specified node is not a directory, the function shall fail. Otherwise it shall allocate a directory cookie and store it in the variable <emphasis>_cookie</emphasis> points to. A subsequent <ref refid="structfs__vnode__ops_1a482878bf7588145c42d16c012a3de2e8" kindref="member">read_dir()</ref> using the cookie shall start reading the first entry of the directory.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a pre-allocated variable the directory cookie shall be written to. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="193" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="193" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a9aad7de463ad795183ea5daaad46fe07" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::close_dir)(fs_volume *volume, fs_vnode *vnode, void *cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie)</argsstring>
        <name>close_dir</name>
        <qualifiedname>fs_vnode_ops::close_dir</qualifiedname>
        <briefdescription>
<para>Closes the given directory cookie. </para>
        </briefdescription>
        <detaileddescription>
<para>Generally the situation is similar to the one described for <ref refid="structfs__vnode__ops_1a0be1b1f60bf8b8d39e3668051e62a138" kindref="member">close()</ref>. In practice it is a bit different, though, since directory cookies are exclusively used for directory iteration, and it normally doesn&apos;t make sense to have multiple threads read the same directory concurrently. Furthermore usually reading a directory will not block. Therefore for most FSs this hook is a no-op.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The directory cookie as returned by <ref refid="structfs__vnode__ops_1a973d90db38ea724859e8a1b708ed70c8" kindref="member">open_dir()</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="195" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="195" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1addbc2c6a0a5ac5a0768afa397ee7bcb4" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::free_dir_cookie)(fs_volume *volume, fs_vnode *vnode, void *cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie)</argsstring>
        <name>free_dir_cookie</name>
        <qualifiedname>fs_vnode_ops::free_dir_cookie</qualifiedname>
        <briefdescription>
<para>Frees the given directory cookie. </para>
        </briefdescription>
        <detaileddescription>
<para>The hook is invoked after <ref refid="structfs__vnode__ops_1a9aad7de463ad795183ea5daaad46fe07" kindref="member">close_dir()</ref>, when no other thread uses or is going to use the cookie. All resources associated with the cookie must be freed.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The directory cookie as returned by <ref refid="structfs__vnode__ops_1a973d90db38ea724859e8a1b708ed70c8" kindref="member">open_dir()</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="196" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="196" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a482878bf7588145c42d16c012a3de2e8" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::read_dir)(fs_volume *volume, fs_vnode *vnode, void *cookie, struct dirent *buffer, size_t bufferSize, uint32 *_num)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, struct dirent *buffer, size_t bufferSize, uint32 *_num)</argsstring>
        <name>read_dir</name>
        <qualifiedname>fs_vnode_ops::read_dir</qualifiedname>
        <briefdescription>
<para>Reads the next one or more directory entries. </para>
        </briefdescription>
        <detaileddescription>
<para>The number of entries to be read at maximum is stored in the variable <emphasis>_num</emphasis> points to.</para>
<para>Per read <computeroutput>dirent</computeroutput> the following fields have to be filled in:<itemizedlist>
<listitem><para><computeroutput>d_dev:</computeroutput> The volume ID.</para>
</listitem><listitem><para><computeroutput>d_ino:</computeroutput> The ID of the node the entry refers to.</para>
</listitem><listitem><para><computeroutput>d_name:</computeroutput> The null-terminated name of the entry.</para>
</listitem><listitem><para><computeroutput>d_reclen:</computeroutput> The size of the <computeroutput>dirent</computeroutput> structure in bytes, starting from the beginning of the structure, counting all bytes up to and including the null-termination char of the name stored in <computeroutput>d_name</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>If more than one entry is read, the corresponding <computeroutput>dirent</computeroutput> structures are tightly packed, i.e. the second entry can begin directly after the end of the first one (i.e. <computeroutput>d_reclen</computeroutput> bytes after the beginning of the first one). The file system should make sure that the dirents are 8-byte aligned, i.e. when another entry follows, <computeroutput>d_reclen</computeroutput> of the previous one should be aligned. A FS doesn&apos;t have to read more than one entry at a time, but it is recommended to support that for performance reasons.</para>
<para>If the provided buffer is too small to contain even the single next entry, <computeroutput>B_BUFFER_OVERFLOW</computeroutput> shall be returned. It shall not fail, if at least one entry has been read, and the buffer is just too small to hold as many entries as requested. When the function is invoked after the end of the directory has been reached, it shall set the variable <emphasis>_num</emphasis> points to <computeroutput>0</computeroutput> and return <computeroutput>B_OK</computeroutput>. Usually the function is invoked repeatedly until then to get more entries. The <computeroutput>cookie</computeroutput> parameter must be used to track the position in the directory.</para>
<para>Note that a directory is expected to contain the special entries <computeroutput>&quot;.&quot;</computeroutput> and <computeroutput>&quot;..&quot;</computeroutput>, referring to the same directory and the parent directory respectively. The <computeroutput>dirent</computeroutput> structure returned for the <computeroutput>&quot;..&quot;</computeroutput> entry of the volume&apos;s root directory shall refer to the root node itself.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The directory cookie as returned by <ref refid="structfs__vnode__ops_1a973d90db38ea724859e8a1b708ed70c8" kindref="member">open_dir()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a pre-allocated buffer the directory entries shall be written to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bufferSize</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of <emphasis>buffer</emphasis> in bytes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_num</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a pre-allocated variable, when invoked, containing the number of directory entries to be read, and into which the number of entries actually read shall be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="198" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="198" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a5648333f7cfa51ab717f7cbdc06a6e01" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::rewind_dir)(fs_volume *volume, fs_vnode *vnode, void *cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie)</argsstring>
        <name>rewind_dir</name>
        <qualifiedname>fs_vnode_ops::rewind_dir</qualifiedname>
        <briefdescription>
<para>Resets the directory cookie to the first entry of the directory. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The directory cookie as returned by <ref refid="structfs__vnode__ops_1a973d90db38ea724859e8a1b708ed70c8" kindref="member">open_dir()</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="200" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="200" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Attribute Directory Operations</header>
      <memberdef kind="variable" id="structfs__vnode__ops_1a61b0d04a6e6ad5f38459df3d6d31ca6e" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::open_attr_dir)(fs_volume *volume, fs_vnode *vnode, void **_cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void **_cookie)</argsstring>
        <name>open_attr_dir</name>
        <qualifiedname>fs_vnode_ops::open_attr_dir</qualifiedname>
        <briefdescription>
<para>Open a &apos;directory&apos; of attributes for a <emphasis>vnode</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ref refid="fs_modules_1concepts" kindref="member">Generic Concepts</ref> on directories and iterators. Basically, the VFS uses the same way of traversing through attributes as it traverses through a directory.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">_cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer where the file system can store a directory cookie if the attribute directory is succesfully opened. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="204" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="204" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a0743e780cfa66797a53ad33af1c01a05" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::close_attr_dir)(fs_volume *volume, fs_vnode *vnode, void *cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie)</argsstring>
        <name>close_attr_dir</name>
        <qualifiedname>fs_vnode_ops::close_attr_dir</qualifiedname>
        <briefdescription>
<para>Close a &apos;directory&apos; of attributes for a <emphasis>vnode</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that you should free the cookie in the <ref refid="structfs__vnode__ops_1a9182af3a0526ebfde859aae5faf8bf29" kindref="member">free_attr_dir_cookie()</ref> call.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The cookie associated with this &apos;directory&apos;. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="206" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="206" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a9182af3a0526ebfde859aae5faf8bf29" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::free_attr_dir_cookie)(fs_volume *volume, fs_vnode *vnode, void *cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie)</argsstring>
        <name>free_attr_dir_cookie</name>
        <qualifiedname>fs_vnode_ops::free_attr_dir_cookie</qualifiedname>
        <briefdescription>
<para>Free the <emphasis>cookie</emphasis> to an attribute &apos;directory&apos;. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The cookie associated that should be freed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="208" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="208" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1af1822e3343810ad20d8f397765f43818" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::read_attr_dir)(fs_volume *volume, fs_vnode *vnode, void *cookie, struct dirent *buffer, size_t bufferSize, uint32 *_num)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, struct dirent *buffer, size_t bufferSize, uint32 *_num)</argsstring>
        <name>read_attr_dir</name>
        <qualifiedname>fs_vnode_ops::read_attr_dir</qualifiedname>
        <briefdescription>
<para>Read the next one or more attribute directory entries. </para>
        </briefdescription>
        <detaileddescription>
<para>This method should perform the same tasks as <ref refid="structfs__vnode__ops_1a482878bf7588145c42d16c012a3de2e8" kindref="member">read_dir()</ref>, except that the &apos;.&apos; and &apos;..&apos; entries do not have to be present. Also, only the <computeroutput>d_name</computeroutput> and <computeroutput>d_reclen</computeroutput> fields have to be filled in. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="210" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="210" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a5eaf98ee3bdc36b44fe0015a80608096" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::rewind_attr_dir)(fs_volume *volume, fs_vnode *vnode, void *cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie)</argsstring>
        <name>rewind_attr_dir</name>
        <qualifiedname>fs_vnode_ops::rewind_attr_dir</qualifiedname>
        <briefdescription>
<para>Rewind the attribute directory iterator to the first entry. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The cookie associated with this &apos;directory&apos;. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="213" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="213" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Attribute Operations</header>
      <memberdef kind="variable" id="structfs__vnode__ops_1a7d96acf480522f8aa9bdc47c4b12df79" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::create_attr)(fs_volume *volume, fs_vnode *vnode, const char *name, uint32 type, int openMode, void **_cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, const char *name, uint32 type, int openMode, void **_cookie)</argsstring>
        <name>create_attr</name>
        <qualifiedname>fs_vnode_ops::create_attr</qualifiedname>
        <briefdescription>
<para>Create a new attribute. </para>
        </briefdescription>
        <detaileddescription>
<para>If the attribute already exists, you should open it in truncated mode.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the attribute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>type_code</computeroutput> of the attribute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>openMode</parametername>
</parameternamelist>
<parameterdescription>
<para>The openMode of the associated attribute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">_cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer where you can store an associated file system cookie. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="217" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="217" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1aab042ad6188813ec7135c9ea178817fb" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::open_attr)(fs_volume *volume, fs_vnode *vnode, const char *name, int openMode, void **_cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, const char *name, int openMode, void **_cookie)</argsstring>
        <name>open_attr</name>
        <qualifiedname>fs_vnode_ops::open_attr</qualifiedname>
        <briefdescription>
<para>Open an existing attribute. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the attribute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>openMode</parametername>
</parameternamelist>
<parameterdescription>
<para>The mode in which you want to open the attribute data. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">_cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer where you can store an associated file system cookie. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="220" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="220" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a7e2eb5ea74abdb56e2428758289cace4" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::close_attr)(fs_volume *volume, fs_vnode *vnode, void *cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie)</argsstring>
        <name>close_attr</name>
        <qualifiedname>fs_vnode_ops::close_attr</qualifiedname>
        <briefdescription>
<para>Close access to an attribute. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that you should not delete the cookie yet, you should do that when the VFS calls <ref refid="structfs__vnode__ops_1a71f2a439c802a2b5939c5c6a2dcfcbcd" kindref="member">free_attr_cookie()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The cookie you associated with this attribute. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="222" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="222" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a71f2a439c802a2b5939c5c6a2dcfcbcd" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::free_attr_cookie)(fs_volume *volume, fs_vnode *vnode, void *cookie)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie)</argsstring>
        <name>free_attr_cookie</name>
        <qualifiedname>fs_vnode_ops::free_attr_cookie</qualifiedname>
        <briefdescription>
<para>Free the cookie of an attribute. </para>
        </briefdescription>
        <detaileddescription>
<para>The VFS calls this hook when all operations on the attribute have ceased.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The cookie to the attribute that should be freed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="224" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="224" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1ad24a42fb776303c720ddb21ecb4ef7bd" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::read_attr)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, void *buffer, size_t *length)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, void *buffer, size_t *length)</argsstring>
        <name>read_attr</name>
        <qualifiedname>fs_vnode_ops::read_attr</qualifiedname>
        <briefdescription>
<para>Read attribute data. </para>
        </briefdescription>
        <detaileddescription>
<para>Read until the <emphasis>buffer</emphasis> with size <emphasis>length</emphasis> is full, or until you are out of data, in which case you should update <emphasis>length</emphasis>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The cookie you associated with this attribute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>The position to start reading from. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The buffer the data should be copied in. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>The length of the buffer. Update this variable to the actual amount of bytes read. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="226" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="226" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a138971075e32e275c66ba1a9369c8c44" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::write_attr)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const void *buffer, size_t *length)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const void *buffer, size_t *length)</argsstring>
        <name>write_attr</name>
        <qualifiedname>fs_vnode_ops::write_attr</qualifiedname>
        <briefdescription>
<para>Write attribute data. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The cookie you associated with this attribute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>The position to start writing to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The buffer the data should be copied from. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the buffer. Update this variable to the actual amount of bytes written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="228" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="228" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a1453fd0c00381a4172835bbb763623ca" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::read_attr_stat)(fs_volume *volume, fs_vnode *vnode, void *cookie, struct stat *stat)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, struct stat *stat)</argsstring>
        <name>read_attr_stat</name>
        <qualifiedname>fs_vnode_ops::read_attr_stat</qualifiedname>
        <briefdescription>
<para>Get the stats for an attribute. </para>
        </briefdescription>
        <detaileddescription>
<para>Only the <computeroutput>st_size</computeroutput> and <computeroutput>st_type</computeroutput> fields need to be filled in.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The cookie you associated with this attribute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stat</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to a stat structure you should fill. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="231" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="231" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a9a5df58b82d4f51212cccedaddd3bace" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::write_attr_stat)(fs_volume *volume, fs_vnode *vnode, void *cookie, const struct stat *stat, int statMask)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, const struct stat *stat, int statMask)</argsstring>
        <name>write_attr_stat</name>
        <qualifiedname>fs_vnode_ops::write_attr_stat</qualifiedname>
        <briefdescription>
<para>Update the stats of an attribute. </para>
        </briefdescription>
        <detaileddescription>
<para>Currently on the attribute size (B_STAT_SIZE) can be set.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cookie</parametername>
</parameternamelist>
<parameterdescription>
<para>The cookie you associated with this attribute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stat</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to the new stats you should write. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>statMask</parametername>
</parameternamelist>
<parameterdescription>
<para>One or more of the values of write_stat_mask that tell you which fields of <emphasis>stat</emphasis> are to be updated. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="233" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="233" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1ae6c357ddeea07883f07e2a1e5652d7cd" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::rename_attr)(fs_volume *volume, fs_vnode *fromVnode, const char *fromName, fs_vnode *toVnode, const char *toName)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *fromVnode, const char *fromName, fs_vnode *toVnode, const char *toName)</argsstring>
        <name>rename_attr</name>
        <qualifiedname>fs_vnode_ops::rename_attr</qualifiedname>
        <briefdescription>
<para>Rename and/or relocate an attribute. </para>
        </briefdescription>
        <detaileddescription>
<para>Currently there&apos;s no userland or kernel API moving an attribute from one node to another. So this hook is to allowed to only support the case where <emphasis>fromVnode</emphasis> and <emphasis>toVnode</emphasis> are equal and fail otherwise.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fromVnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object for the vnode the attribute currently belongs to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fromName</parametername>
</parameternamelist>
<parameterdescription>
<para>The old name of the attribute. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>toVnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object for the vnode the attribute should be moved to. This can be the same as <emphasis>fromVnode</emphasis>, in which case it only means the attribute should be renamed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>toName</parametername>
</parameternamelist>
<parameterdescription>
<para>The new name of the attribute. This can be the same as <emphasis>fromName</emphasis>, in which case it only means the attribute should be relocated. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>The renaming and/or relocating succeeded. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_BAD_VALUE</parametername>
</parameternamelist>
<parameterdescription>
<para>One of the supplied parameters were invalid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_NOT_ALLOWED</parametername>
</parameternamelist>
<parameterdescription>
<para>The user does not have the proper permissions. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>other errors</parametername>
</parameternamelist>
<parameterdescription>
<para>Another error condition was encountered. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="235" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="235" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1adf2a75bf57bebd367e5439af92f97871" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::remove_attr)(fs_volume *volume, fs_vnode *vnode, const char *name)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, const char *name)</argsstring>
        <name>remove_attr</name>
        <qualifiedname>fs_vnode_ops::remove_attr</qualifiedname>
        <briefdescription>
<para>Remove an attribute. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>volume</parametername>
</parameternamelist>
<parameterdescription>
<para>The volume object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vnode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the attribute. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> if everything went fine, another error code otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="237" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="237" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Node and FS Layers</header>
      <memberdef kind="variable" id="structfs__vnode__ops_1afd34769cb5d4508916b97e8cb2c3668a" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::create_special_node)(fs_volume *volume, fs_vnode *dir, const char *name, fs_vnode *subVnode, mode_t mode, uint32 flags, fs_vnode *_superVnode, ino_t *_nodeID)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *dir, const char *name, fs_vnode *subVnode, mode_t mode, uint32 flags, fs_vnode *_superVnode, ino_t *_nodeID)</argsstring>
        <name>create_special_node</name>
        <qualifiedname>fs_vnode_ops::create_special_node</qualifiedname>
        <briefdescription>
<para>TODO: Document! </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="241" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="241" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a0555cf7b7f053faca3793cff4d1f08f8" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::get_super_vnode)(fs_volume *volume, fs_vnode *vnode, fs_volume *superVolume, fs_vnode *superVnode)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, fs_volume *superVolume, fs_vnode *superVnode)</argsstring>
        <name>get_super_vnode</name>
        <qualifiedname>fs_vnode_ops::get_super_vnode</qualifiedname>
        <briefdescription>
<para>TODO: Document! </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="244" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="244" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="structfs__vnode__ops_1a7ad249eb61f2edf8579c6b06205f1291" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::acquire_lock) (fs_volume *volume, fs_vnode *vnode, void *cookie, const struct flock *lock, bool wait)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, const struct flock *lock, bool wait)</argsstring>
        <name>acquire_lock</name>
        <qualifiedname>fs_vnode_ops::acquire_lock</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="250" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="250" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1a8994988950ca42f65d3394a6355be36c" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::preallocate) (fs_volume *volume, fs_vnode *vnode, off_t pos, off_t length)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, off_t pos, off_t length)</argsstring>
        <name>preallocate</name>
        <qualifiedname>fs_vnode_ops::preallocate</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="171" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="171" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1af2f3a236fa7c0841034284f929678df7" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::release_lock) (fs_volume *volume, fs_vnode *vnode, void *cookie, const struct flock *lock)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, const struct flock *lock)</argsstring>
        <name>release_lock</name>
        <qualifiedname>fs_vnode_ops::release_lock</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="252" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="252" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structfs__vnode__ops_1ad0cb03c4b6351624099d863ffcc86670" prot="public" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref>(*</type>
        <definition>status_t(* fs_vnode_ops::test_lock) (fs_volume *volume, fs_vnode *vnode, void *cookie, struct flock *lock)</definition>
        <argsstring>)(fs_volume *volume, fs_vnode *vnode, void *cookie, struct flock *lock)</argsstring>
        <name>test_lock</name>
        <qualifiedname>fs_vnode_ops::test_lock</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="248" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="248" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Operations vector for a node. </para>
    </briefdescription>
    <detaileddescription>
<para>See the <ref refid="fs_modules" kindref="compound">introduction to file system modules</ref> for an introduction to writing file systems. </para>
    </detaileddescription>
    <location file="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" line="116" column="1" bodyfile="/boot/home/src/haiku/headers/os/drivers/fs_interface.h" bodystart="116" bodyend="254"/>
    <listofallmembers>
      <member refid="structfs__vnode__ops_1a86ed7b682fa1006e353167845f4e7d60" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>access</name></member>
      <member refid="structfs__vnode__ops_1a7ad249eb61f2edf8579c6b06205f1291" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>acquire_lock</name></member>
      <member refid="structfs__vnode__ops_1a5e77e519fd95be45e32050e0acfabc15" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>can_page</name></member>
      <member refid="structfs__vnode__ops_1adc95f2deb18ce46d91b0d372a7d98179" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>cancel_io</name></member>
      <member refid="structfs__vnode__ops_1a0be1b1f60bf8b8d39e3668051e62a138" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>close</name></member>
      <member refid="structfs__vnode__ops_1a7e2eb5ea74abdb56e2428758289cace4" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>close_attr</name></member>
      <member refid="structfs__vnode__ops_1a0743e780cfa66797a53ad33af1c01a05" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>close_attr_dir</name></member>
      <member refid="structfs__vnode__ops_1a9aad7de463ad795183ea5daaad46fe07" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>close_dir</name></member>
      <member refid="structfs__vnode__ops_1a7b09be06f0c168397d62b4348d90c245" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>create</name></member>
      <member refid="structfs__vnode__ops_1a7d96acf480522f8aa9bdc47c4b12df79" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>create_attr</name></member>
      <member refid="structfs__vnode__ops_1aa3a5019b2694449020131280f46883cd" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>create_dir</name></member>
      <member refid="structfs__vnode__ops_1afd34769cb5d4508916b97e8cb2c3668a" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>create_special_node</name></member>
      <member refid="structfs__vnode__ops_1aeb6d3f5493748470a7894c6e6486d324" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>create_symlink</name></member>
      <member refid="structfs__vnode__ops_1af641c9244f8125d5669834a0fb7cb3bd" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>deselect</name></member>
      <member refid="structfs__vnode__ops_1a71f2a439c802a2b5939c5c6a2dcfcbcd" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>free_attr_cookie</name></member>
      <member refid="structfs__vnode__ops_1a9182af3a0526ebfde859aae5faf8bf29" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>free_attr_dir_cookie</name></member>
      <member refid="structfs__vnode__ops_1a86efe64fe11783e782da8054c50cebce" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>free_cookie</name></member>
      <member refid="structfs__vnode__ops_1addbc2c6a0a5ac5a0768afa397ee7bcb4" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>free_dir_cookie</name></member>
      <member refid="structfs__vnode__ops_1a426627e06dd3c6bfbfd9565ae622fb3b" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>fsync</name></member>
      <member refid="structfs__vnode__ops_1ad70a0d678d291a0c800fa76eb9c7de3f" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>get_file_map</name></member>
      <member refid="structfs__vnode__ops_1a0555cf7b7f053faca3793cff4d1f08f8" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>get_super_vnode</name></member>
      <member refid="structfs__vnode__ops_1ae84954a5adbbc10c39d5d64d4852748f" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>get_vnode_name</name></member>
      <member refid="structfs__vnode__ops_1a506f223092153b00da5f67216760496c" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>io</name></member>
      <member refid="structfs__vnode__ops_1aff6789e84faad7959cd6511a78d6cd1d" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>ioctl</name></member>
      <member refid="structfs__vnode__ops_1a3bb3ba7ca9d0cf2f83bdc5c4097f703a" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>link</name></member>
      <member refid="structfs__vnode__ops_1a5ebce4ebee27ad71016359467fb81fe7" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>lookup</name></member>
      <member refid="structfs__vnode__ops_1a153038dfcab23bfedaf0a3657a1bb01a" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>open</name></member>
      <member refid="structfs__vnode__ops_1aab042ad6188813ec7135c9ea178817fb" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>open_attr</name></member>
      <member refid="structfs__vnode__ops_1a61b0d04a6e6ad5f38459df3d6d31ca6e" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>open_attr_dir</name></member>
      <member refid="structfs__vnode__ops_1a973d90db38ea724859e8a1b708ed70c8" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>open_dir</name></member>
      <member refid="structfs__vnode__ops_1a8994988950ca42f65d3394a6355be36c" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>preallocate</name></member>
      <member refid="structfs__vnode__ops_1a13873870794c714e5b470cf6e3e1bf22" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>put_vnode</name></member>
      <member refid="structfs__vnode__ops_1a3d5f1013644389c3efee43b3e175aa34" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>read</name></member>
      <member refid="structfs__vnode__ops_1ad24a42fb776303c720ddb21ecb4ef7bd" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>read_attr</name></member>
      <member refid="structfs__vnode__ops_1af1822e3343810ad20d8f397765f43818" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>read_attr_dir</name></member>
      <member refid="structfs__vnode__ops_1a1453fd0c00381a4172835bbb763623ca" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>read_attr_stat</name></member>
      <member refid="structfs__vnode__ops_1a482878bf7588145c42d16c012a3de2e8" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>read_dir</name></member>
      <member refid="structfs__vnode__ops_1ac58b1b4ff8908d84f25259df8bea572a" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>read_pages</name></member>
      <member refid="structfs__vnode__ops_1a645a7315d3274a84958586c543efb6b6" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>read_stat</name></member>
      <member refid="structfs__vnode__ops_1acbf78b533817de642e1ab9c3d69797a2" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>read_symlink</name></member>
      <member refid="structfs__vnode__ops_1af2f3a236fa7c0841034284f929678df7" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>release_lock</name></member>
      <member refid="structfs__vnode__ops_1adf2a75bf57bebd367e5439af92f97871" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>remove_attr</name></member>
      <member refid="structfs__vnode__ops_1ae91372438edbe5575432cb7fd5308d35" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>remove_dir</name></member>
      <member refid="structfs__vnode__ops_1a104571b9d1b232b87ce0db208b0393e0" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>remove_vnode</name></member>
      <member refid="structfs__vnode__ops_1a9f492cb3f6b8576da5b9b61720382071" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>rename</name></member>
      <member refid="structfs__vnode__ops_1ae6c357ddeea07883f07e2a1e5652d7cd" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>rename_attr</name></member>
      <member refid="structfs__vnode__ops_1a5eaf98ee3bdc36b44fe0015a80608096" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>rewind_attr_dir</name></member>
      <member refid="structfs__vnode__ops_1a5648333f7cfa51ab717f7cbdc06a6e01" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>rewind_dir</name></member>
      <member refid="structfs__vnode__ops_1a3cdcec6960aa08e7abfdd02f1c8e22d3" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>select</name></member>
      <member refid="structfs__vnode__ops_1a4831dd9e1d3e99797b41d6ed147b70ad" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>set_flags</name></member>
      <member refid="structfs__vnode__ops_1ad0cb03c4b6351624099d863ffcc86670" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>test_lock</name></member>
      <member refid="structfs__vnode__ops_1a61236086b99dff3f53f2842349d67917" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>unlink</name></member>
      <member refid="structfs__vnode__ops_1a6b15bdec37363749b7dcf5e05b04d6ba" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>write</name></member>
      <member refid="structfs__vnode__ops_1a138971075e32e275c66ba1a9369c8c44" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>write_attr</name></member>
      <member refid="structfs__vnode__ops_1a9a5df58b82d4f51212cccedaddd3bace" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>write_attr_stat</name></member>
      <member refid="structfs__vnode__ops_1ac3f066c19be99f884721a279523e9b19" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>write_pages</name></member>
      <member refid="structfs__vnode__ops_1a1658906a3924b698a34baa2bd8757ea5" prot="public" virt="non-virtual"><scope>fs_vnode_ops</scope><name>write_stat</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
