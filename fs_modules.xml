<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="fs_modules" kind="page">
    <compoundname>fs_modules</compoundname>
    <title>File System Modules</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>To support a particular file system (FS), a kernel module implementing a special interface (<computeroutput><ref refid="structfile__system__module__info" kindref="compound">file_system_module_info</ref></computeroutput> defined in <computeroutput>&lt;<ref refid="fs__interface_8h" kindref="compound">fs_interface.h</ref>&gt;</computeroutput>) has to be provided. As for any other module the <computeroutput>std_ops()</computeroutput> hook is invoked with <computeroutput>B_MODULE_INIT</computeroutput> directly after the FS module has been loaded by the kernel, and with <computeroutput>B_MODULE_UNINIT</computeroutput> before it is unloaded, thus providing a simple mechanism for one-time module initializations. The same module is used for accessing any volume of that FS type.</para>
<sect1 id="fs_modules_1objects">
<title>File System Objects</title>
<para>There are several types of objects a FS module has to deal with directly or indirectly:</para>
<para><itemizedlist>
<listitem><para>A <emphasis>volume</emphasis> is an instance of a file system. For a disk-based file system it corresponds to a disk, partition, or disk image file. When mounting a volume the virtual file system layer (VFS) assigns a unique number (ID, of type <computeroutput>dev_t</computeroutput>) to it and a handle (type <computeroutput>void*</computeroutput>) provided by the file system. The VFS creates an instance of struct <computeroutput>fs_volume</computeroutput> that stores these two, an operation vector (<computeroutput><ref refid="structfs__volume__ops" kindref="compound">fs_volume_ops</ref></computeroutput>), and other volume related items. Whenever the FS is asked to perform an operation the <computeroutput>fs_volume</computeroutput> object is supplied, and whenever the FS requests a volume-related service from the kernel, it also has to pass the <computeroutput>fs_volume</computeroutput> object or, in some cases, just the volume ID. Normally the handle is a pointer to a data structure the FS allocates to associate data with the volume.</para>
</listitem><listitem><para>A <emphasis>node</emphasis> is contained by a volume. It can be of type file, directory, or symbolic link (symlink). Just as volumes nodes are associated with an ID (type <computeroutput>ino_t</computeroutput>) and, if in use, also with a handle (type <computeroutput>void*</computeroutput>). As for volumes the VFS creates an instance of a structure (<computeroutput>fs_vnode</computeroutput>) for each node in use, storing the FS&apos;s handle for the node and an operation vector (<computeroutput><ref refid="structfs__vnode__ops" kindref="compound">fs_vnode_ops</ref></computeroutput>). Unlike the volume ID the node ID is defined by the FS. It often has a meaning to the FS, e.g. file systems using inodes might choose the inode number corresponding to the node. As long as the volume is mounted and the node is known to the VFS, its node ID must not change. The node handle is again a pointer to a data structure allocated by the FS.</para>
</listitem><listitem><para>A <emphasis>vnode</emphasis> (VFS node) is the VFS representation of a node. A volume may contain a great number of nodes, but at a time only a few are represented by vnodes, usually only those that are currently in use (sometimes a few more).</para>
</listitem><listitem><para>An <emphasis>entry</emphasis> (directory entry) belongs to a directory, has a name, and refers to a node. It is important to understand the difference between entries and nodes: A node doesn&apos;t have a name, only the entries that refer to it have. If a FS supports to have more than one entry refer to a single node, it is also said to support &quot;hard links&quot;. It is possible that no entry refers to a node. This happens when a node (e.g. a file) is still open, but the last entry referring to it has been removed (the node will be deleted when the it is closed). While entries are to be understood as independent entities, the FS interface does not use IDs or handles to refer to them; it always uses directory and entry name pairs to do that.</para>
</listitem><listitem><para>An <emphasis>attribute</emphasis> is a named and typed data container belonging to a node. A node may have any number of attributes; they are organized in a (depending on the FS, virtual or actually existing) attribute directory, through which one can iterate.</para>
</listitem><listitem><para>An <emphasis>index</emphasis> is supposed to provide fast searching capabilities for attributes with a certain name. A volume&apos;s index directory allows for iterating through the indices.</para>
</listitem><listitem><para>A <emphasis>query</emphasis> is a fully virtual object for searching for entries via an expression matching entry name, node size, node modification date, and/or node attributes. The mechanism of retrieving the entries found by a query is similar to that for reading a directory contents. A query can be live in which case the creator of the query is notified by the FS whenever an entry no longer matches the query expression or starts matching.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="fs_modules_1concepts">
<title>Generic Concepts</title>
<para>A FS module has to (or can) provide quite a lot of hook functions. There are a few concepts that apply to several groups of them:</para>
<para><itemizedlist>
<listitem><para><emphasis>Opening, Closing, and Cookies</emphasis>: Many FS objects can be opened and closed, namely nodes in general, directories, attribute directories, attributes, the index directory, and queries. In each case there are three hook functions: <computeroutput>open*()</computeroutput>, <computeroutput>close*()</computeroutput>, and <computeroutput>free*_cookie()</computeroutput>. The <computeroutput>open*()</computeroutput> hook is passed all that is needed to identify the object to be opened and, in some cases, additional parameters e.g. specifying a particular opening mode. The implementation is required to return a cookie (type <computeroutput>void*</computeroutput>), usually a pointer to a data structure the FS allocates. In some cases (e.g. when an iteration state is associated with the cookie) a new cookie must be allocated for each instance of opening the object. The cookie is passed to all hooks that operate on a thusly opened object. The <computeroutput>close*()</computeroutput> hook is invoked to signal that the cookie is to be closed. At this point the cookie might still be in use. Blocking FS hooks (e.g. blocking read/write operations) using the same cookie have to be unblocked. When the cookie stops being in use the <computeroutput>free*_cookie()</computeroutput> hook is called; it has to free the cookie.</para>
</listitem><listitem><para><emphasis>Entry Iteration</emphasis>: For the FS objects serving as containers for other objects, i.e. directories, attribute directories, the index directory, and queries, the cookie mechanism is used for a stateful iteration through the contained objects. The <computeroutput>read_*()</computeroutput> hook reads the next one or more entries into a <computeroutput>struct dirent</computeroutput> buffer. The <computeroutput>rewind_*()</computeroutput> hook resets the iteration state to the first entry.</para>
</listitem><listitem><para><emphasis>Stat Information</emphasis>: In case of nodes, attributes, and indices detailed information about an object are requested via a <computeroutput>read*_stat()</computeroutput> hook and must be written into a <computeroutput>struct stat</computeroutput> buffer.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="fs_modules_1vnodes">
<title>VNodes</title>
<para>A vnode is the VFS representation of a node. As soon as an access to a node is requested, the VFS creates a corresponding vnode. The requesting entity gets a reference to the vnode for the time it works with the vnode and releases the reference when done. When the last reference to a vnode has been surrendered, the vnode is unused and the VFS can decide to destroy it (usually it is cached for a while longer).</para>
<para>When the VFS creates a vnode, it invokes the volume&apos;s <ref refid="structfs__volume__ops_1adc3a3f3ee1a553ed684dff2e25268485" kindref="member">get_vnode() </ref> hook to let it create the respective node handle (unless the FS requests the creation of the vnode explicitely by calling <ref refid="fs__interface_8h_1a72ca7437ee63b0b91ade75d2d0a24413" kindref="member">publish_vnode()</ref>). That&apos;s the only hook that specifies a node by ID; all other node-related hooks are defined in the respective node&apos;s operation vector and they are passed the respective <computeroutput>fs_vnode</computeroutput> object. When the VFS deletes the vnode, it invokes the nodes&apos;s <ref refid="structfs__vnode__ops_1a13873870794c714e5b470cf6e3e1bf22" kindref="member">put_vnode() </ref> hook or, if the node was marked removed, <ref refid="structfs__vnode__ops_1a104571b9d1b232b87ce0db208b0393e0" kindref="member">remove_vnode() </ref>.</para>
<para>There are only four FS hooks through which the VFS gains knowledge of the existence of a node. The first one is the <ref refid="structfile__system__module__info_1ad59987c29f64dde1ef161e5870fd0d9e" kindref="member">mount() </ref> hook. It is supposed to call <computeroutput><ref refid="fs__interface_8h_1a72ca7437ee63b0b91ade75d2d0a24413" kindref="member">publish_vnode()</ref></computeroutput> for the root node of the volume and return its ID. The second one is the <ref refid="structfs__vnode__ops_1a5ebce4ebee27ad71016359467fb81fe7" kindref="member">lookup() </ref> hook. Given a <computeroutput>fs_vnode</computeroutput> object of a directory and an entry name, it is supposed to call <computeroutput><ref refid="fs__interface_8h_1a2cfcf01bba17eee0ad3f84115051b281" kindref="member">get_vnode()</ref></computeroutput> for the node the entry refers to and return the node ID. The remaining two hooks, <ref refid="structfs__vnode__ops_1a482878bf7588145c42d16c012a3de2e8" kindref="member">read_dir() </ref> and <ref refid="structfs__volume__ops_1a3517e1d8551f4fb847c0b95e4811ff80" kindref="member">read_query() </ref>, both return entries in a <computeroutput>struct dirent</computeroutput> structure, which also contains the ID of the node the entry refers to.</para>
</sect1>
<sect1 id="fs_modules_1mandatory_hooks">
<title>Mandatory Hooks</title>
<para>Which hooks a FS module should provide mainly depends on what functionality it features. E.g. a FS without support for attribute, indices, and/or queries can omit the respective hooks (i.e. set them to <computeroutput>NULL</computeroutput> in the module, <computeroutput><ref refid="structfs__volume__ops" kindref="compound">fs_volume_ops</ref></computeroutput>, and <computeroutput><ref refid="structfs__vnode__ops" kindref="compound">fs_vnode_ops</ref></computeroutput> structure). Some hooks are mandatory, though. A minimal read-only FS module must implement:</para>
<para><itemizedlist>
<listitem><para><ref refid="structfile__system__module__info_1ad59987c29f64dde1ef161e5870fd0d9e" kindref="member">mount() </ref> and <ref refid="structfs__volume__ops_1a587e1b6ce260710cb2f0edaacade938b" kindref="member">unmount() </ref>: Mounting and unmounting a volume is required for pretty obvious reasons.</para>
</listitem><listitem><para><ref refid="structfs__vnode__ops_1a5ebce4ebee27ad71016359467fb81fe7" kindref="member">lookup() </ref>: The VFS uses this hook to resolve path names. It is probably one of the most frequently invoked hooks.</para>
</listitem><listitem><para><ref refid="structfs__volume__ops_1adc3a3f3ee1a553ed684dff2e25268485" kindref="member">get_vnode() </ref> and <ref refid="structfs__vnode__ops_1a13873870794c714e5b470cf6e3e1bf22" kindref="member">put_vnode() </ref>: Create respectively destroy the FS&apos;s private node handle when the VFS creates/deletes the vnode for a particular node.</para>
</listitem><listitem><para><ref refid="structfs__vnode__ops_1a645a7315d3274a84958586c543efb6b6" kindref="member">read_stat() </ref>: Return a <computeroutput>struct stat</computeroutput> info for the given node, consisting of the type and size of the node, its owner and access permissions, as well as certain access times.</para>
</listitem><listitem><para><ref refid="structfs__vnode__ops_1a153038dfcab23bfedaf0a3657a1bb01a" kindref="member">open() </ref>, <ref refid="structfs__vnode__ops_1a0be1b1f60bf8b8d39e3668051e62a138" kindref="member">close() </ref>, and <ref refid="structfs__vnode__ops_1a86efe64fe11783e782da8054c50cebce" kindref="member">free_cookie() </ref>: Open and close a node as explained in <ref refid="fs_modules_1concepts" kindref="member">Generic Concepts</ref>.</para>
</listitem><listitem><para><ref refid="structfs__vnode__ops_1a3d5f1013644389c3efee43b3e175aa34" kindref="member">read() </ref>: Read data from an opened node (file). Even if the FS does not feature files, the hook has to be present anyway; it should return an error in this case.</para>
</listitem><listitem><para><ref refid="structfs__vnode__ops_1a973d90db38ea724859e8a1b708ed70c8" kindref="member">open_dir() </ref>, <ref refid="structfs__vnode__ops_1a9aad7de463ad795183ea5daaad46fe07" kindref="member">close_dir() </ref>, and <ref refid="structfs__vnode__ops_1addbc2c6a0a5ac5a0768afa397ee7bcb4" kindref="member">free_dir_cookie() </ref>: Open and close a directory for entry iteration as explained in <ref refid="fs_modules_1concepts" kindref="member">Generic Concepts</ref>.</para>
</listitem><listitem><para><ref refid="structfs__vnode__ops_1a482878bf7588145c42d16c012a3de2e8" kindref="member">read_dir() </ref> and <ref refid="structfs__vnode__ops_1a5648333f7cfa51ab717f7cbdc06a6e01" kindref="member">rewind_dir() </ref>: Read the next entry/entries from a directory, respectively reset the iterator to the first entry, as explained in <ref refid="fs_modules_1concepts" kindref="member">Generic Concepts</ref>.</para>
</listitem></itemizedlist>
</para>
<para>Although not strictly mandatory, a FS should additionally implement the following hooks:</para>
<para><itemizedlist>
<listitem><para><ref refid="structfs__volume__ops_1a40451a3d0fb15d9c3f00dd5e64947b27" kindref="member">read_fs_info() </ref>: Return general information about the volume, e.g. total and free size, and what special features (attributes, MIME types, queries) the volume/FS supports.</para>
</listitem><listitem><para><ref refid="structfs__vnode__ops_1acbf78b533817de642e1ab9c3d69797a2" kindref="member">read_symlink() </ref>: Read the value of a symbolic link. Needed only, if the FS and volume support symbolic links at all. If absent symbolic links stored on the volume won&apos;t be interpreted.</para>
</listitem><listitem><para><ref refid="structfs__vnode__ops_1a86ed7b682fa1006e353167845f4e7d60" kindref="member">access() </ref>: Return whether the current user has the given access permissions for a node. If the hook is absent the user is considered to have all permissions.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="fs_modules_1permissions">
<title>Checking Access Permission</title>
<para>While there is the <ref refid="structfs__vnode__ops_1a86ed7b682fa1006e353167845f4e7d60" kindref="member">access() </ref> hook that explicitly checks access permission for a node, it is not used by the VFS to check access permissions for the other hooks. This has two reasons: It could be cheaper for the FS to do that in the respective hook (at least it&apos;s not more expensive), and the FS can make sure that there are no race conditions between the check and the start of the operation for the hook. The downside is that in most hooks the FS has to check those permissions. It is possible to simplify things a bit, though:</para>
<para><itemizedlist>
<listitem><para>For operations that require the file system object in question (node, directory, index, attribute, attribute directory, query) to be open, most of the checks can already be done in the respective <computeroutput>open*()</computeroutput> hook. E.g. in <ref refid="structfs__vnode__ops_1a3d5f1013644389c3efee43b3e175aa34" kindref="member">fs_vnode_ops::read()</ref> or <ref refid="structfs__vnode__ops_1a6b15bdec37363749b7dcf5e05b04d6ba" kindref="member">fs_vnode_ops::write()</ref> one only has to check, if the file has been opened for reading/writing, not whether the current process has the respective permissions.</para>
</listitem><listitem><para>The core of the <ref refid="structfs__vnode__ops_1a86ed7b682fa1006e353167845f4e7d60" kindref="member">fs_vnode_ops::access()</ref> hook can be moved into a private function that can be easily reused in other hooks to check the permissions for the respective operations. In most cases this will reduce permission checking to one or two additional &quot;if&quot;s in the hooks where it is required.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="fs_modules_1node_monitoring">
<title>Node Monitoring</title>
<para>One of the nice features of Haiku&apos;s API is an easy way to monitor directories or nodes for changes. That is one can register for watching a given node for certain modification events and will get a notification message whenever one of those events occurs. While other parts of the operating system do the actual notification message delivery, it is the responsibility of each file system to announce changes. It has to use the following functions to do that:</para>
<para><itemizedlist>
<listitem><para><ref refid="fs__interface_8h_1a55cd489f984ce5fc12a8ecbc7f6751e8" kindref="member">notify_entry_created()</ref>: A directory entry has been created.</para>
</listitem><listitem><para><ref refid="fs__interface_8h_1a3baac1c403f1ecff4ad83db13a72eefa" kindref="member">notify_entry_removed()</ref>: A directory entry has been removed.</para>
</listitem><listitem><para><ref refid="fs__interface_8h_1a470097f27af472b8d39f30c58b8fab0f" kindref="member">notify_entry_moved()</ref>: A directory entry has been renamed and/or moved to another directory.</para>
</listitem><listitem><para><ref refid="fs__interface_8h_1ac46396596f5c06ecd4247a909edee103" kindref="member">notify_stat_changed()</ref>: One or more members of the stat data for node have changed. E.g. the <computeroutput>st_size</computeroutput> member changes when the file is truncated or data have been written to it beyond its former size. The modification time (<computeroutput>st_mtime</computeroutput>) changes whenever a node is write-accessed. To avoid a flood of messages for small and frequent write operations on an open file the file system can limit the number of notifications and mark them with the B_WATCH_INTERIM_STAT flag. When closing a modified file a notification without that flag should be issued.</para>
</listitem><listitem><para><ref refid="fs__interface_8h_1ab3b03ad1ba412bb75cdae495f282425c" kindref="member">notify_attribute_changed()</ref>: An attribute of a node has been added, removed, or changed.</para>
</listitem></itemizedlist>
</para>
<para>If the file system supports queries, it needs to call the following functions to make live queries work:</para>
<para><itemizedlist>
<listitem><para><ref refid="fs__interface_8h_1a4a9de58136e078f3b99430a07b5e096e" kindref="member">notify_query_entry_created()</ref>: A change caused an entry that didn&apos;t match the query predicate before to match now.</para>
</listitem><listitem><para><ref refid="fs__interface_8h_1a65efb61891fd7f412b7a06401f0e8e1a" kindref="member">notify_query_entry_removed()</ref>: A change caused an entry that matched the query predicate before to no longer match.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="fs_modules_1caches">
<title>Caches</title>
<para>The Haiku kernel provides three kinds of caches that can be used by a file system implementation to speed up file system operations:</para>
<para><itemizedlist>
<listitem><para><emphasis>Block cache</emphasis>: Interesting for disk-based file systems. The device the file system volume is located on is considered to be divided in equally-sized blocks of data that can be accessed via the block cache API (e.g. block_cache_get() and block_cache_put()). As long as the system has enough memory the block cache will keep all blocks that have been accessed in memory, thus allowing further accesses to be very fast. The block cache also has transaction support, which is of interest for journaled file systems.</para>
</listitem><listitem><para><emphasis>File cache</emphasis>: Stores file contents. The FS can decide to create a file cache for any of its files. The <ref refid="structfs__vnode__ops_1a3d5f1013644389c3efee43b3e175aa34" kindref="member">fs_vnode_ops::read()</ref> and <ref refid="structfs__vnode__ops_1a6b15bdec37363749b7dcf5e05b04d6ba" kindref="member">fs_vnode_ops::write()</ref> hooks can then simply be implemented by calling the file_cache_read() respectively file_cache_write() function, which will read the data from/write the data to the file cache. For reading uncached data or writing back cached data to the file, the file cache will invoke the <ref refid="structfs__vnode__ops_1a506f223092153b00da5f67216760496c" kindref="member">fs_vnode_ops::io()</ref> hook. Only files for which the file cache is used, can be memory mapped (cf. mmap())</para>
</listitem><listitem><para><emphasis>Entry cache</emphasis>: Can be used to speed up resolving paths. Normally the VFS will call the <ref refid="structfs__vnode__ops_1a5ebce4ebee27ad71016359467fb81fe7" kindref="member">fs_vnode_ops::lookup()</ref> hook for each element of the path to be resolved, which, depending on the file system, can be more or less expensive. When the FS uses the entry cache, those calls will be avoided most of the time. All the file system has to do is invoke the entry_cache_add() function when it encounters an entry that might not yet be known to the entry cache and entry_cache_remove() when a directory entry has been removed. The entry cache can also be used for negative caching. If the file system determines that the requested entry is not present during a lookup, it can cache this lookup failure by calling entry_cache_add_missing(). Further calls to <ref refid="structfs__vnode__ops_1a5ebce4ebee27ad71016359467fb81fe7" kindref="member">fs_vnode_ops::lookup()</ref> for the missing entry will then be avoided. Note that it is safe to call entry_cache_add() and entry_cache_add_missing() with the same directory/name pair previously given to either function to update a cache entry, without needing to call entry_cache_remove() first. It is also safe to call entry_cache_remove() for pairs that have never been added to the cache. </para>
</listitem></itemizedlist>
</para>
</sect1>
    </detaileddescription>
    <location file="drivers/fs_modules.dox"/>
  </compounddef>
</doxygen>
