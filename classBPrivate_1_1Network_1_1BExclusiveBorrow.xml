<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="classBPrivate_1_1Network_1_1BExclusiveBorrow" kind="class" language="C++" prot="public">
    <compoundname>BPrivate::Network::BExclusiveBorrow</compoundname>
    <templateparamlist>
      <param>
        <type>typename T</type>
      </param>
    </templateparamlist>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a4bccb57694e8956143a22f849778718c" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>class</type>
        <definition>friend class BBorrow</definition>
        <argsstring></argsstring>
        <name>BBorrow</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::BBorrow</qualifiedname>
        <param>
          <type><ref refid="classBPrivate_1_1Network_1_1BBorrow" kindref="compound">BBorrow</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="110" column="25" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="110" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a4d74a526490513c5a040d1ae63dd4521" prot="private" static="no" mutable="no">
        <type>BorrowAdmin *</type>
        <definition>BorrowAdmin* BPrivate::Network::BExclusiveBorrow&lt; T &gt;::fAdminBlock</definition>
        <argsstring></argsstring>
        <name>fAdminBlock</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::fAdminBlock</qualifiedname>
        <initializer>= nullptr</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="113" column="13" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="113" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a1677a3f28944e93c0e7a1b128915ae88" prot="private" static="no" mutable="no">
        <type>T *</type>
        <definition>T* BPrivate::Network::BExclusiveBorrow&lt; T &gt;::fPtr</definition>
        <argsstring></argsstring>
        <name>fPtr</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::fPtr</qualifiedname>
        <initializer>= nullptr</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="112" column="3" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="112" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1af5b72c221574d182b29f27a1a4eb4518" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>BPrivate::Network::BExclusiveBorrow&lt; T &gt;::BExclusiveBorrow</definition>
        <argsstring>() noexcept</argsstring>
        <name>BExclusiveBorrow</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::BExclusiveBorrow</qualifiedname>
        <briefdescription>
<para>Create a new smart pointer with no value. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="116" column="1" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="116" bodyend="116"/>
      </memberdef>
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a4d2fd4fe4985838dfee5b3a83ff6fe14" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>BPrivate::Network::BExclusiveBorrow&lt; T &gt;::BExclusiveBorrow</definition>
        <argsstring>(BExclusiveBorrow &amp;&amp;other) noexcept</argsstring>
        <name>BExclusiveBorrow</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::BExclusiveBorrow</qualifiedname>
        <param>
          <type><ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow" kindref="compound">BExclusiveBorrow</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Move constructor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>The object to move from. It will be left empty after the move.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="140" column="1" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="140" bodyend="148"/>
      </memberdef>
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1ae48853ba76fad3e7a8f5b23e9ca46d14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>BPrivate::Network::BExclusiveBorrow&lt; T &gt;::BExclusiveBorrow</definition>
        <argsstring>(const BExclusiveBorrow &amp;)=delete</argsstring>
        <name>BExclusiveBorrow</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::BExclusiveBorrow</qualifiedname>
        <param>
          <type>const <ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow" kindref="compound">BExclusiveBorrow</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="134" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a0c6d71369f832a7feb455a6f50c2f68c" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>BPrivate::Network::BExclusiveBorrow&lt; T &gt;::BExclusiveBorrow</definition>
        <argsstring>(nullptr_t) noexcept</argsstring>
        <name>BExclusiveBorrow</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::BExclusiveBorrow</qualifiedname>
        <param>
          <type>nullptr_t</type>
        </param>
        <briefdescription>
<para>Special constructor that creates a new smart pointer with no value. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="119" column="1" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="119" bodyend="119"/>
      </memberdef>
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a3774e0c2fcb68201e285b07f4329aa4f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>BPrivate::Network::BExclusiveBorrow&lt; T &gt;::BExclusiveBorrow</definition>
        <argsstring>(T *object)</argsstring>
        <name>BExclusiveBorrow</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::BExclusiveBorrow</qualifiedname>
        <param>
          <type>T *</type>
          <declname>object</declname>
        </param>
        <briefdescription>
<para>Create a new smart pointer that takes ownership of the <emphasis>object</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>object</parametername>
</parameternamelist>
<parameterdescription>
<para>The object to wrap inside this smart pointer.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::bad_alloc</parametername>
</parameternamelist>
<parameterdescription>
<para>In case there are issues allocating memory for the internals of the smart pointer.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="122" column="1" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="122" bodyend="126"/>
      </memberdef>
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a5404867eb8a34dacbcd9f3c645a4c2d5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>BPrivate::Network::BExclusiveBorrow&lt; T &gt;::~BExclusiveBorrow</definition>
        <argsstring>()</argsstring>
        <name>~BExclusiveBorrow</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::~BExclusiveBorrow</qualifiedname>
        <briefdescription>
<para>Destructor. </para>
        </briefdescription>
        <detaileddescription>
<para>If the smart pointer is not empty, the underlying object will be deleted if there no longer is a borrow accessing it.</para>
<para><simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="128" column="1" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="128" bodyend="132"/>
      </memberdef>
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a3a95bdba411f5f861d2e43170d45b34d" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool BPrivate::Network::BExclusiveBorrow&lt; T &gt;::HasValue</definition>
        <argsstring>() const noexcept</argsstring>
        <name>HasValue</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::HasValue</qualifiedname>
        <briefdescription>
<para>Check if the object has a value or is empty. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="163" column="6" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="163" bodyend="163"/>
      </memberdef>
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a63fe5db991ceabf8ce079587fdcd2892" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>T &amp;</type>
        <definition>T &amp; BPrivate::Network::BExclusiveBorrow&lt; T &gt;::operator*</definition>
        <argsstring>() const</argsstring>
        <name>operator*</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::operator*</qualifiedname>
        <briefdescription>
<para>Dereferences the pointer. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classBPrivate_1_1Network_1_1BBorrowError" kindref="compound">BBorrowError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>This exception is raised if the object is borrowed, or if it is empty.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="166" column="3" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="166" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a14339cc646350e12061f0601be87ede1" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>T *</type>
        <definition>T * BPrivate::Network::BExclusiveBorrow&lt; T &gt;::operator-&gt;</definition>
        <argsstring>() const</argsstring>
        <name>operator-&gt;</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::operator-&gt;</qualifiedname>
        <briefdescription>
<para>Dereferences the pointer. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classBPrivate_1_1Network_1_1BBorrowError" kindref="compound">BBorrowError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>This exception is raised if the object is borrowed, or if it is empty.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="174" column="3" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="174" bodyend="179"/>
      </memberdef>
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1aef3712f61fe6543f81444bd4f2cb9ed4" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type><ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow" kindref="compound">BExclusiveBorrow</ref> &amp;</type>
        <definition>BExclusiveBorrow &amp; BPrivate::Network::BExclusiveBorrow&lt; T &gt;::operator=</definition>
        <argsstring>(BExclusiveBorrow &amp;&amp;other) noexcept</argsstring>
        <name>operator=</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::operator=</qualifiedname>
        <param>
          <type><ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow" kindref="compound">BExclusiveBorrow</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Move assignment. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>The object to move from. It will be left empty after the move.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="151" column="18" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="151" bodyend="160"/>
      </memberdef>
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a15cfd1b2b677e5164b1455e941712390" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow" kindref="compound">BExclusiveBorrow</ref> &amp;</type>
        <definition>BExclusiveBorrow &amp; BPrivate::Network::BExclusiveBorrow&lt; T &gt;::operator=</definition>
        <argsstring>(const BExclusiveBorrow &amp;)=delete</argsstring>
        <name>operator=</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::operator=</qualifiedname>
        <param>
          <type>const <ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow" kindref="compound">BExclusiveBorrow</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="137" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a5a7fc48f8c2892988f9adc2d86b2e78f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::unique_ptr&lt; T &gt;</type>
        <definition>std::unique_ptr&lt; T &gt; BPrivate::Network::BExclusiveBorrow&lt; T &gt;::Release</definition>
        <argsstring>()</argsstring>
        <name>Release</name>
        <qualifiedname>BPrivate::Network::BExclusiveBorrow::Release</qualifiedname>
        <briefdescription>
<para>Returns a unique_ptr of the inner object and releases the ownership. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classBPrivate_1_1Network_1_1BBorrowError" kindref="compound">BBorrowError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>This exception is raised if the object is borrowed, or if it is empty.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="182" column="17" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="182" bodyend="191"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Smart pointer that allows shared ownership of an object with exclusive access. </para>
    </briefdescription>
    <detaileddescription>
<para>This smart pointer was designed to support the particular pattern where a non-threadsafe or non-lockable needs to be shared between two threads, where only one can have access to the underlying object at the time.</para>
<para>When creating a new object, the underlying object can be accessed using the dereference operator overloads as if with any other smart pointer. This ownership can then be borrowed by creating a <ref refid="classBPrivate_1_1Network_1_1BBorrow" kindref="compound">BBorrow</ref> object. At that stage, the original owner can no longer access the underlying object, until the borrow is returned. The borrow can access the object as long as they retain the borrow. The borrow is returned by the borrow object going out of scope, or by the borrow object being assigned a <computeroutput>nullptr</computeroutput> object. At that stage, the original owner regains access.</para>
<para><programlisting><codeline><highlight class="comment">//<sp/>Create<sp/>a<sp/>newly<sp/>owned<sp/>string<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">BExclusiveBorrow&lt;BString&gt;<sp/>owner<sp/>=<sp/>make_exclusive_borrow&lt;BString&gt;(</highlight><highlight class="stringliteral">&quot;Initial<sp/>value&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Access<sp/>the<sp/>exclusively<sp/>accessibe<sp/>object<sp/>and<sp/>set<sp/>it<sp/>to<sp/>a<sp/>different<sp/>value</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">owner-&gt;SetTo(</highlight><highlight class="stringliteral">&quot;New<sp/>value<sp/>set<sp/>by<sp/>owner&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>borrow.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">BBorrow&lt;BString&gt;<sp/>borrow<sp/>=<sp/>BBorrow&lt;BString&gt;(owner);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">try</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>owner-&gt;SetTo(</highlight><highlight class="stringliteral">&quot;Another<sp/>value<sp/>set<sp/>by<sp/>owner&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>BorrowError&amp;<sp/>e)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>error<sp/>will<sp/>be<sp/>thrown<sp/>because<sp/>the<sp/>`owner`<sp/>cannot<sp/>access<sp/>the<sp/>object<sp/>while<sp/>borrowed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">try</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>BBorrow&lt;BString&gt;<sp/>secondBorrow<sp/>=<sp/>BBorrow&lt;BString&gt;(owner);</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>BorrowError&amp;<sp/>e)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>error<sp/>will<sp/>be<sp/>thrown<sp/>because<sp/>there<sp/>cannot<sp/>be<sp/>more<sp/>than<sp/>one<sp/>borrow<sp/>at<sp/>a<sp/>time.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>`borrow`<sp/>has<sp/>exclusive<sp/>access<sp/>to<sp/>the<sp/>underlying<sp/>BString<sp/>object</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">borrow-&gt;SetTo(</highlight><highlight class="stringliteral">&quot;A<sp/>value<sp/>set<sp/>by<sp/>the<sp/>borrower&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>borrow<sp/>is<sp/>returned<sp/>by<sp/>explicitly<sp/>setting<sp/>it<sp/>to<sp/>`nullptr`<sp/>or<sp/>by<sp/>having<sp/>the<sp/>object<sp/>go<sp/>out</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>of<sp/>scope.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">borrow<sp/>=<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>owner<sp/>can<sp/>access<sp/>the<sp/>object<sp/>again</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">assert(*owner<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;A<sp/>value<sp/>set<sp/>by<sp/>the<sp/>borrower&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para>
<para><simplesect kind="par"><title>Object Lifetime Management</title><para>The <ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow" kindref="compound">BExclusiveBorrow</ref> and <ref refid="classBPrivate_1_1Network_1_1BBorrow" kindref="compound">BBorrow</ref> pair manage the lifetime of the underlying object, meaning the memory will be freed when the object is no longer referenced by either the owner or the borrower. It is possible to get the ownership of the underlying object through the <ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a5a7fc48f8c2892988f9adc2d86b2e78f" kindref="member">BExclusiveBorrow::Release()</ref> method. This returns a <computeroutput>unique_ptr</computeroutput>.</para>
</simplesect>
<simplesect kind="par"><title>Creating New Objects</title><para>When creating a <ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow" kindref="compound">BExclusiveBorrow</ref> object, you can use the <ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a3774e0c2fcb68201e285b07f4329aa4f" kindref="member">BExclusiveBorrow(T* object)</ref> constructor to create a new smart pointer that takes an <emphasis>existing</emphasis> underlying object. Note that the smart pointer will assume ownership, meaning that you should also have ownership of that object. If you want to create a <ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow" kindref="compound">BExclusiveBorrow</ref> object for a new object, then you can use the <ref refid="group__netservices_1ga9d2f443c775ed1dff92d0cd6196adf93" kindref="member">make_exclusive_borrow()</ref> function to create a new object.</para>
</simplesect>
<simplesect kind="par"><title>Move Semantics and Empty Objects</title><para>The template class is designed around having an underlying object value, and in most cases will have an underlying object. However, there may be cases where a BExclusiveOwner or <ref refid="classBPrivate_1_1Network_1_1BBorrow" kindref="compound">BBorrow</ref> object will not have an internal value. This either happens when it is explicitly assigned an empty value, or after the object has been moved. You can check whether the object has a value through the <ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a3a95bdba411f5f861d2e43170d45b34d" kindref="member">HasValue()</ref> method. Trying to access an empty object will throw a <ref refid="classBPrivate_1_1Network_1_1BBorrowError" kindref="compound">BBorrowError</ref>.</para>
</simplesect>
<simplesect kind="par"><title>Checked Access</title><para>The semantics of the exclusive ownership are enforced by this class. The rules are:<itemizedlist>
<listitem><para>There can only be one owner. The object cannot be copied, only moved.</para>
</listitem><listitem><para>There can only be one borrower at a time. The borrow object cannot be copied, only moved.</para>
</listitem><listitem><para>If one tries to create an additional borrow, an exception is thrown.</para>
</listitem><listitem><para>If an object is borrowed, accessing it through the owner will throw exceptions.</para>
</listitem></itemizedlist>
</para>
</simplesect>
<simplesect kind="par"><title>Casting Pointers between Owner and Borrower</title><para>For some design patterns, you may want to be able to cast the type of the owner to a related type for the borrower. For example, the <ref refid="namespaceBPrivate_1_1Network" kindref="compound">Network</ref> Services kit accepts a <computeroutput>BBorrow&lt;BDataIO&gt;</computeroutput> type in order to allow the user to specify where to write the content of a network request to. The <ref refid="classBDataIO" kindref="compound">BDataIO</ref> itself is an abstract interface to read and write data from an object. A user will most likely use a <ref refid="classBFile" kindref="compound">BFile</ref> or <ref refid="classBMallocIO" kindref="compound">BMallocIO</ref> as underlying objects, both of which have <ref refid="classBDataIO" kindref="compound">BDataIO</ref> as their base class.</para>
</simplesect>
<simplesect kind="par"><title></title><para>Due to the specialized constructor of <ref refid="classBPrivate_1_1Network_1_1BBorrow" kindref="compound">BBorrow</ref>, it is possible to cast between compatible pointer types, without loosing the advantages of properly cleaning up the object when the borrow and the owner go out of scope. In the internals of the template, a type erasure technique similar to that of <computeroutput>std::shared_ptr</computeroutput> is used.</para>
</simplesect>
<programlisting><codeline><highlight class="comment">//<sp/>Create<sp/>a<sp/>new<sp/>BFile<sp/>object,<sp/>which<sp/>inherits<sp/>the<sp/>BDataIO<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">BExclusiveBorrow&lt;BFile&gt;<sp/>owner<sp/>=<sp/>make_exclusive_borrow&lt;BFile&gt;(</highlight><highlight class="stringliteral">&quot;path/to/file&quot;</highlight><highlight class="normal">,<sp/>B_READ_WRITE);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>following<sp/>succeeds<sp/>because<sp/>a<sp/>BFile<sp/>pointer<sp/>can<sp/>be<sp/>assigned<sp/>to<sp/>a<sp/>BDataIO<sp/>pointer.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">BBorrow&lt;BDataIO&gt;<sp/>borrow<sp/>=<sp/>BBorrow&lt;BDataIO&gt;(owner);</highlight></codeline>
</programlisting></para>
<para><simplesect kind="par"><title>Multithread Safety, and Performance Cost</title><para>This smart object uses atomics to synchronize the ownership and borrows of the object, and to enforce all the checks that were mentioned previously. The atomics guarantee that when you want to access the object in <ref refid="classBPrivate_1_1Network_1_1BExclusiveBorrow" kindref="compound">BExclusiveBorrow</ref>, that this only succeeds after any outstanding borrow is completed, otherwise an exception is thrown. While atomics can be used as a method of synchronization, this templace class is <emphasis>not</emphasis> designed for that and it does not have the tools to help doing that. If you need to synchronize object access between through threads, you should use semaphores or thread joins instead.</para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of object for this smart pointer.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" line="108" column="11" bodyfile="/boot/home/src/haiku/headers/private/netservices2/ExclusiveBorrow.h" bodystart="109" bodyend="192"/>
    <listofallmembers>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1af5b72c221574d182b29f27a1a4eb4518" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>BExclusiveBorrow</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a0c6d71369f832a7feb455a6f50c2f68c" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>BExclusiveBorrow</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a3774e0c2fcb68201e285b07f4329aa4f" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>BExclusiveBorrow</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1ae48853ba76fad3e7a8f5b23e9ca46d14" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>BExclusiveBorrow</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a4d2fd4fe4985838dfee5b3a83ff6fe14" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>BExclusiveBorrow</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a4d74a526490513c5a040d1ae63dd4521" prot="private" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>fAdminBlock</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a1677a3f28944e93c0e7a1b128915ae88" prot="private" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>fPtr</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a3a95bdba411f5f861d2e43170d45b34d" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>HasValue</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a63fe5db991ceabf8ce079587fdcd2892" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>operator*</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a14339cc646350e12061f0601be87ede1" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>operator-&gt;</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a15cfd1b2b677e5164b1455e941712390" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>operator=</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1aef3712f61fe6543f81444bd4f2cb9ed4" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>operator=</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a5a7fc48f8c2892988f9adc2d86b2e78f" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>Release</name></member>
      <member refid="classBPrivate_1_1Network_1_1BExclusiveBorrow_1a5404867eb8a34dacbcd9f3c645a4c2d5" prot="public" virt="non-virtual"><scope>BPrivate::Network::BExclusiveBorrow</scope><name>~BExclusiveBorrow</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
