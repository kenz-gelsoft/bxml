<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="classBPathFinder" kind="class" language="C++" prot="public">
    <compoundname>BPathFinder</compoundname>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classBPathFinder_1a2ec3a5dffd3704a705bc7da138b38aed" prot="public" static="no">
        <type>BPackageKit::BPackageResolvableExpression</type>
        <definition>typedef BPackageKit::BPackageResolvableExpression BPathFinder::BResolvableExpression</definition>
        <argsstring></argsstring>
        <name>BResolvableExpression</name>
        <qualifiedname>BPathFinder::BResolvableExpression</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="25" column="1" bodyfile="/boot/home/src/haiku/headers/os/storage/PathFinder.h" bodystart="25" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classBPathFinder_1ad3e7aacc1a239067bb628dbed1a2352e" prot="private" static="no" mutable="no">
        <type>const void *</type>
        <definition>const void* BPathFinder::fCodePointer</definition>
        <argsstring></argsstring>
        <name>fCodePointer</name>
        <qualifiedname>BPathFinder::fCodePointer</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="78" column="11" bodyfile="/boot/home/src/haiku/headers/os/storage/PathFinder.h" bodystart="78" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classBPathFinder_1a1bb41a7860ccf84754b4cac1476c5789" prot="private" static="no" mutable="no">
        <type><ref refid="classBString" kindref="compound">BString</ref></type>
        <definition>BString BPathFinder::fDependency</definition>
        <argsstring></argsstring>
        <name>fDependency</name>
        <qualifiedname>BPathFinder::fDependency</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="80" column="8" bodyfile="/boot/home/src/haiku/headers/os/storage/PathFinder.h" bodystart="80" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classBPathFinder_1a2dba2c2bf12e2a5635468e20b08234f5" prot="private" static="no" mutable="no">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::fInitStatus</definition>
        <argsstring></argsstring>
        <name>fInitStatus</name>
        <qualifiedname>BPathFinder::fInitStatus</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="81" column="9" bodyfile="/boot/home/src/haiku/headers/os/storage/PathFinder.h" bodystart="81" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classBPathFinder_1a33e34df330188116fe14e025aa07aa3e" prot="private" static="no" mutable="no">
        <type><ref refid="classBString" kindref="compound">BString</ref></type>
        <definition>BString BPathFinder::fPath</definition>
        <argsstring></argsstring>
        <name>fPath</name>
        <qualifiedname>BPathFinder::fPath</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="79" column="8" bodyfile="/boot/home/src/haiku/headers/os/storage/PathFinder.h" bodystart="79" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classBPathFinder_1a6f3d1ca7745a70031ca1d5ad14edf8c9" prot="private" static="no" mutable="no">
        <type>addr_t</type>
        <definition>addr_t BPathFinder::fReserved[4]</definition>
        <argsstring>[4]</argsstring>
        <name>fReserved</name>
        <qualifiedname>BPathFinder::fReserved</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="82" column="7" bodyfile="/boot/home/src/haiku/headers/os/storage/PathFinder.h" bodystart="82" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classBPathFinder_1a5bf296f6e46ac468209dac444f8f114b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>BPathFinder::BPathFinder</definition>
        <argsstring>(const BResolvableExpression &amp;expression, const char *dependency=NULL)</argsstring>
        <name>BPathFinder</name>
        <qualifiedname>BPathFinder::BPathFinder</qualifiedname>
        <param>
          <type>const BResolvableExpression &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>dependency</declname>
          <defval><ref refid="SupportDefs_8h_1a070d2ce7b6bb7e5c05602aa8c308d0c4" kindref="member">NULL</ref></defval>
        </param>
        <briefdescription>
<para>Creates an object referring to an installation location based on the path of a package satisfying the given resolvable expression. </para>
        </briefdescription>
        <detaileddescription>
<para>The constructor finds the latest package that satisfies the resolvable expression <emphasis>expression</emphasis> and then uses its path to initialize the object like <ref refid="classBPathFinder_1a93c4e093bbe3e99758a8222abf548a5c" kindref="member">BPathFinder::BPathFinder(const char*, const char*)</ref>.</para>
<para><simplesect kind="note"><para>When using this constructor linking against libpackage.so is required.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expression</parametername>
</parameternamelist>
<parameterdescription>
<para>A resolvable expression to be resolved to the path of the latest package satisfying it, based on which <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> shall compute the path. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dependency</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the package&apos;s &quot;requires&quot; entry to be used for resolving the installation location. Can be <computeroutput>NULL</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="classBPathFinder_1a93c4e093bbe3e99758a8222abf548a5c" kindref="member">BPathFinder::BPathFinder(const char*, const char*)</ref></para>
</simplesect>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="34" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1a93c4e093bbe3e99758a8222abf548a5c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>BPathFinder::BPathFinder</definition>
        <argsstring>(const char *path, const char *dependency=NULL)</argsstring>
        <name>BPathFinder</name>
        <qualifiedname>BPathFinder::BPathFinder</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>path</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>dependency</declname>
          <defval><ref refid="SupportDefs_8h_1a070d2ce7b6bb7e5c05602aa8c308d0c4" kindref="member">NULL</ref></defval>
        </param>
        <briefdescription>
<para>Creates an object referring to an installation location based on a given <emphasis>path</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>When initialized with this constructor a <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> method called afterward evaluates the path constant passed to it based on <emphasis>path</emphasis>. In most cases that means first determining the path of the installation location from the given <emphasis>path</emphasis>.</para>
<para>If <emphasis>dependency</emphasis> is specified, instead of determining the installation location path from the given path, the installation location path of the dependency <emphasis>dependency</emphasis> of the package containing the file referred to by <emphasis>path</emphasis> is used.</para>
<para>If the initialization fails, e.g. due to insufficient memory or invalid arguments, subsequent calls to <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> will return an error.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>path</parametername>
</parameternamelist>
<parameterdescription>
<para>A path based on which <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> shall compute the path. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dependency</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the package&apos;s &quot;requires&quot; entry to be used for resolving the installation location. Can be <computeroutput>NULL</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="30" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1a24a6178102ad509becb312a467cebb89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>BPathFinder::BPathFinder</definition>
        <argsstring>(const entry_ref &amp;ref, const char *dependency=NULL)</argsstring>
        <name>BPathFinder</name>
        <qualifiedname>BPathFinder::BPathFinder</qualifiedname>
        <param>
          <type>const <ref refid="structentry__ref" kindref="compound">entry_ref</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>dependency</declname>
          <defval><ref refid="SupportDefs_8h_1a070d2ce7b6bb7e5c05602aa8c308d0c4" kindref="member">NULL</ref></defval>
        </param>
        <briefdescription>
<para>Creates an object referring to an installation location based on a given <ref refid="structentry__ref" kindref="compound">entry_ref</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>The constructor converts the given <ref refid="structentry__ref" kindref="compound">entry_ref</ref> <emphasis>ref</emphasis> to a path and then initializes the object like <ref refid="classBPathFinder_1a93c4e093bbe3e99758a8222abf548a5c" kindref="member">BPathFinder::BPathFinder(const char*, const char*)</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ref</parametername>
</parameternamelist>
<parameterdescription>
<para>A reference to be resolved to a path based on which <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> shall compute the path. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dependency</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the package&apos;s &quot;requires&quot; entry to be used for resolving the installation location. Can be <computeroutput>NULL</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="classBPathFinder_1a93c4e093bbe3e99758a8222abf548a5c" kindref="member">BPathFinder::BPathFinder(const char*, const char*)</ref></para>
</simplesect>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="32" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1a3c7a42103ed1d0a87c60d488ed3181d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>BPathFinder::BPathFinder</definition>
        <argsstring>(const void *codePointer=NULL, const char *dependency=NULL)</argsstring>
        <name>BPathFinder</name>
        <qualifiedname>BPathFinder::BPathFinder</qualifiedname>
        <param>
          <type>const void *</type>
          <declname>codePointer</declname>
          <defval><ref refid="SupportDefs_8h_1a070d2ce7b6bb7e5c05602aa8c308d0c4" kindref="member">NULL</ref></defval>
        </param>
        <param>
          <type>const char *</type>
          <declname>dependency</declname>
          <defval><ref refid="SupportDefs_8h_1a070d2ce7b6bb7e5c05602aa8c308d0c4" kindref="member">NULL</ref></defval>
        </param>
        <briefdescription>
<para>Creates an object referring to an installation location based on a loaded image file. </para>
        </briefdescription>
        <detaileddescription>
<para>When initialized with this constructor a <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> method called afterward determines the path of the image (i.e. executable, library, or add-on) file associated with <emphasis>codePointer</emphasis>, a pointer to a location in the code or static data of an image loaded in the caller&apos;s team. Based on that path the path constant passed to <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> will be evaluated. In most cases that means first determining the path of the installation location from the path.</para>
<para>If <emphasis>dependency</emphasis> is specified, instead of determining the installation location path from the image path, the installation location path of the dependency <emphasis>dependency</emphasis> of the package containing the image file is used.</para>
<para>If the initialization fails, e.g. due to insufficient memory or invalid arguments, subsequent calls to <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> will return an error.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>codePointer</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to code or static data belonging to the image based on which <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> shall compute the path. The special value <computeroutput>B_APP_IMAGE_SYMBOL</computeroutput> (the default) can be used to refer to the program image, and <computeroutput>B_CURRENT_IMAGE_SYMBOL</computeroutput> for the caller&apos;s image. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dependency</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the package&apos;s &quot;requires&quot; entry to be used for resolving the installation location. Can be <computeroutput>NULL</computeroutput> (the default).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="28" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1a6430c47700b38075404d427f48b37868" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::FindPath</definition>
        <argsstring>(const char *architecture, path_base_directory baseDirectory, const char *subPath, uint32 flags, BPath &amp;_path)</argsstring>
        <name>FindPath</name>
        <qualifiedname>BPathFinder::FindPath</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>architecture</declname>
        </param>
        <param>
          <type><ref refid="FindDirectory_8h_1a8497db5ef25d4ff28530546cefd13232" kindref="member">path_base_directory</ref></type>
          <declname>baseDirectory</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>subPath</declname>
        </param>
        <param>
          <type><ref refid="SupportDefs_8h_1a9a72138d173e1e5243078b8644d4a1c2" kindref="member">uint32</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="classBPath" kindref="compound">BPath</ref> &amp;</type>
          <declname>_path</declname>
        </param>
        <briefdescription>
<para>Retrieves a path in the file system layout based. </para>
        </briefdescription>
        <detaileddescription>
<para>Depending on how the object was initialized this method starts with a path (from an image file or as given) and based on it evaluates <emphasis>baseDirectory</emphasis>. In most cases that means first determining the path of the installation location from the path, then appending the relative path corresponding to the given <emphasis>baseDirectory</emphasis> constant, and finally appending <emphasis>subPath</emphasis>, if given.</para>
<para>If a dependency string was passed to the previous constructor or <ref refid="classBPathFinder_1a852db3b34c79cbe2e8d2bf2b9d651d53" kindref="member">SetTo()</ref> method, instead of determining the installation location path from the initial path, the installation location path of the dependency of the package containing the file the initial path refers to is used.</para>
<para>If <emphasis>baseDirectory</emphasis> specifies a path that is architecture dependent, <emphasis>architecture</emphasis> is used for constructing the path. If <emphasis>architecture</emphasis> is <computeroutput>NULL</computeroutput>, the architecture associated with the initial path (as returned by <ref refid="Architecture_8h_1af6527c1353b821375656e9720d033a1e" kindref="member">guess_architecture_for_path()</ref>) is used. Note that if an image was specified, this is the same as the caller&apos;s architecture (as returned by <ref refid="Architecture_8h_1a9d717f29f2e0b8d913b8d5be020a8bb3" kindref="member">get_architecture()</ref>).</para>
<para>If <computeroutput>B_FIND_PATH_IMAGE_PATH</computeroutput> or <computeroutput>B_FIND_PATH_PACKAGE_PATH</computeroutput> are specified, <emphasis>subPath</emphasis> is ignored. In the former case, which is only valid, if an image was specified for initialization, <emphasis>dependency</emphasis> is ignored as well and the path of the image file is returned. In the latter case the path of the package containing the file the initial path refers to, respectively, if <emphasis>dependency</emphasis> was specified, that of the package <emphasis>dependency</emphasis> was resolved to is returned.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>architecture</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the architecture to be used for resolving <emphasis>architecture</emphasis> dependent paths. Can be <computeroutput>NULL</computeroutput>, in which case the <emphasis>architecture</emphasis> associated with the initial path is used. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>baseDirectory</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant indicating which path to retrieve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>subPath</parametername>
</parameternamelist>
<parameterdescription>
<para>Relative subpath that shall be appended. Can be <computeroutput>NULL</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Bitwise OR of any of the following flags:<itemizedlist>
<listitem><para><computeroutput>B_FIND_PATH_CREATE_DIRECTORY:</computeroutput> If the resulting path doesn&apos;t exist, create it as a directory (including all missing ancestors).</para>
</listitem><listitem><para><computeroutput>B_FIND_PATH_CREATE_PARENT_DIRECTORY:</computeroutput> If the resulting path&apos;s parent doesn&apos;t exist, create the parent directory (including all missing ancestors).</para>
</listitem><listitem><para><computeroutput>B_FIND_PATH_EXISTING_ONLY:</computeroutput> If the resulting path doesn&apos;t exist, fail with <computeroutput>B_ENTRY_NOT_FOUND</computeroutput>. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_path</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be set to the resulting path on success.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A status code. </para>
</simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Everything went fine. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_ENTRY_NOT_FOUND</parametername>
</parameternamelist>
<parameterdescription>
<para>A file system entry required for retrieving the path didn&apos;t exist, e.g. <computeroutput>B_FIND_PATH_PACKAGE_PATH</computeroutput> was specified and the image file didn&apos;t belong to a package, or <computeroutput>dependency</computeroutput> was specified, but wasn&apos;t a &quot;requires&quot; entry of the package, or <computeroutput>B_FIND_PATH_EXISTING_ONLY</computeroutput> was specified and the resulting path didn&apos;t exist.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="49" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1a769fed5369dfe5ca73cc14dc321afef1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::FindPath</definition>
        <argsstring>(path_base_directory baseDirectory, BPath &amp;_path)</argsstring>
        <name>FindPath</name>
        <qualifiedname>BPathFinder::FindPath</qualifiedname>
        <param>
          <type><ref refid="FindDirectory_8h_1a8497db5ef25d4ff28530546cefd13232" kindref="member">path_base_directory</ref></type>
          <declname>baseDirectory</declname>
        </param>
        <param>
          <type><ref refid="classBPath" kindref="compound">BPath</ref> &amp;</type>
          <declname>_path</declname>
        </param>
        <briefdescription>
<para>Retrieves a path in the file system layout based. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to a call to <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">BPathFinder::FindPath(const char*,
path_base_directory, const char*, uint32, BPath&amp;)</ref> with a <computeroutput>NULL</computeroutput> architecture, 0 flags, and <computeroutput>NULL</computeroutput> subpath.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>baseDirectory</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant indicating which path to retrieve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_path</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be set to the resulting path on success. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A status code. </para>
</simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Everything went fine. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_ENTRY_NOT_FOUND</parametername>
</parameternamelist>
<parameterdescription>
<para>A file system entry required for retrieving the path didn&apos;t exist, e.g. <computeroutput>B_FIND_PATH_PACKAGE_PATH</computeroutput> was specified and the image file didn&apos;t belong to a package, or <computeroutput>dependency</computeroutput> was specified, but wasn&apos;t a &quot;requires&quot; entry of the package.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="58" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1a9e0e6558f8070334dc56632bac6058ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::FindPath</definition>
        <argsstring>(path_base_directory baseDirectory, const char *subPath, BPath &amp;_path)</argsstring>
        <name>FindPath</name>
        <qualifiedname>BPathFinder::FindPath</qualifiedname>
        <param>
          <type><ref refid="FindDirectory_8h_1a8497db5ef25d4ff28530546cefd13232" kindref="member">path_base_directory</ref></type>
          <declname>baseDirectory</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>subPath</declname>
        </param>
        <param>
          <type><ref refid="classBPath" kindref="compound">BPath</ref> &amp;</type>
          <declname>_path</declname>
        </param>
        <briefdescription>
<para>Retrieves a path in the file system layout based. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to a call to <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">BPathFinder::FindPath(const char*,
path_base_directory, const char*, uint32, BPath&amp;)</ref> with a <computeroutput>NULL</computeroutput> architecture and 0 flags.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>baseDirectory</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant indicating which path to retrieve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>subPath</parametername>
</parameternamelist>
<parameterdescription>
<para>Relative subpath that shall be appended. Can be <computeroutput>NULL</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_path</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be set to the resulting path on success.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A status code. </para>
</simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Everything went fine. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_ENTRY_NOT_FOUND</parametername>
</parameternamelist>
<parameterdescription>
<para>A file system entry required for retrieving the path didn&apos;t exist, e.g. <computeroutput>B_FIND_PATH_PACKAGE_PATH</computeroutput> was specified and the image file didn&apos;t belong to a package, or <computeroutput>dependency</computeroutput> was specified, but wasn&apos;t a &quot;requires&quot; entry of the package. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="56" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1aae646784db3ec1c29844b6312d857250" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::FindPath</definition>
        <argsstring>(path_base_directory baseDirectory, const char *subPath, uint32 flags, BPath &amp;_path)</argsstring>
        <name>FindPath</name>
        <qualifiedname>BPathFinder::FindPath</qualifiedname>
        <param>
          <type><ref refid="FindDirectory_8h_1a8497db5ef25d4ff28530546cefd13232" kindref="member">path_base_directory</ref></type>
          <declname>baseDirectory</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>subPath</declname>
        </param>
        <param>
          <type><ref refid="SupportDefs_8h_1a9a72138d173e1e5243078b8644d4a1c2" kindref="member">uint32</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="classBPath" kindref="compound">BPath</ref> &amp;</type>
          <declname>_path</declname>
        </param>
        <briefdescription>
<para>Retrieves a path in the file system layout based. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to a call to <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">BPathFinder::FindPath(const char*,
path_base_directory, const char*, uint32, BPath&amp;)</ref> with a <computeroutput>NULL</computeroutput> architecture.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>baseDirectory</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant indicating which path to retrieve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>subPath</parametername>
</parameternamelist>
<parameterdescription>
<para>Relative subpath that shall be appended. Can be <computeroutput>NULL</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Bitwise OR of any of the following flags:<itemizedlist>
<listitem><para><computeroutput>B_FIND_PATH_CREATE_DIRECTORY:</computeroutput> If the resulting path doesn&apos;t exist, create it as a directory (including all missing ancestors).</para>
</listitem><listitem><para><computeroutput>B_FIND_PATH_CREATE_PARENT_DIRECTORY:</computeroutput> If the resulting path&apos;s parent doesn&apos;t exist, create the parent directory (including all missing ancestors).</para>
</listitem><listitem><para><computeroutput>B_FIND_PATH_EXISTING_ONLY:</computeroutput> If the resulting path doesn&apos;t exist, fail with <computeroutput>B_ENTRY_NOT_FOUND</computeroutput>. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_path</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable to be set to the resulting path on success.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A status code. </para>
</simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Everything went fine. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_ENTRY_NOT_FOUND</parametername>
</parameternamelist>
<parameterdescription>
<para>A file system entry required for retrieving the path didn&apos;t exist, e.g. <computeroutput>B_FIND_PATH_PACKAGE_PATH</computeroutput> was specified and the image file didn&apos;t belong to a package, or <computeroutput>dependency</computeroutput> was specified, but wasn&apos;t a &quot;requires&quot; entry of the package, or <computeroutput>B_FIND_PATH_EXISTING_ONLY</computeroutput> was specified and the resulting path didn&apos;t exist.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="53" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1af6afaf9aae2355b57978e660338bd642" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::SetTo</definition>
        <argsstring>(const BResolvableExpression &amp;expression, const char *dependency=NULL)</argsstring>
        <name>SetTo</name>
        <qualifiedname>BPathFinder::SetTo</qualifiedname>
        <param>
          <type>const BResolvableExpression &amp;</type>
          <declname>expression</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>dependency</declname>
          <defval><ref refid="SupportDefs_8h_1a070d2ce7b6bb7e5c05602aa8c308d0c4" kindref="member">NULL</ref></defval>
        </param>
        <briefdescription>
<para>Reinitializes the object to refer to an installation location based on a given resolvable expression. </para>
        </briefdescription>
        <detaileddescription>
<para>This method finds the latest package that satisfies the resolvable expression <emphasis>expression</emphasis> and then passes its path to <ref refid="classBPathFinder_1a6a97b207ffcc8212c74f994fb6e16f66" kindref="member">BPathFinder::SetTo(const char*, const char*)</ref>.</para>
<para><simplesect kind="note"><para>When using this method linking against libpackage.so is required.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expression</parametername>
</parameternamelist>
<parameterdescription>
<para>A resolvable expression to be resolved to the path of the latest package satisfying it, based on which <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> shall compute the path. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dependency</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the package&apos;s &quot;requires&quot; entry to be used for resolving the installation location. Can be <computeroutput>NULL</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref> <ref refid="classBPathFinder_1a6a97b207ffcc8212c74f994fb6e16f66" kindref="member">BPathFinder::SetTo(const char*, const char*)</ref></para>
</simplesect>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> Everything if went fine or an error code otherwise.</para>
</simplesect>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="45" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1a6a97b207ffcc8212c74f994fb6e16f66" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::SetTo</definition>
        <argsstring>(const char *path, const char *dependency=NULL)</argsstring>
        <name>SetTo</name>
        <qualifiedname>BPathFinder::SetTo</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>path</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>dependency</declname>
          <defval><ref refid="SupportDefs_8h_1a070d2ce7b6bb7e5c05602aa8c308d0c4" kindref="member">NULL</ref></defval>
        </param>
        <briefdescription>
<para>Reinitializes the object to refer to an installation location based on a given <emphasis>path</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>When reinitialized with this method a <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> method called afterward evaluates the path constant passed to it based on <emphasis>path</emphasis>. In most cases that means first determining the path of the installation location from the given <emphasis>path</emphasis>.</para>
<para>If <emphasis>dependency</emphasis> is specified, instead of determining the installation location path from the given path, the installation location path of the dependency <emphasis>dependency</emphasis> of the package containing the file referred to by <emphasis>path</emphasis> is used.</para>
<para>If the initialization fails, e.g. due to insufficient memory or invalid arguments, this method and subsequent calls to <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> will return an error.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>path</parametername>
</parameternamelist>
<parameterdescription>
<para>A path based on which <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> shall compute the path. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dependency</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the package&apos;s &quot;requires&quot; entry to be used for resolving the installation location. Can be <computeroutput>NULL</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> Everything if went fine or an error code otherwise.</para>
</simplesect>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="41" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1afa658250375811e03bf8a53094bd9422" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::SetTo</definition>
        <argsstring>(const entry_ref &amp;ref, const char *dependency=NULL)</argsstring>
        <name>SetTo</name>
        <qualifiedname>BPathFinder::SetTo</qualifiedname>
        <param>
          <type>const <ref refid="structentry__ref" kindref="compound">entry_ref</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>dependency</declname>
          <defval><ref refid="SupportDefs_8h_1a070d2ce7b6bb7e5c05602aa8c308d0c4" kindref="member">NULL</ref></defval>
        </param>
        <briefdescription>
<para>Reinitializes the object to refer to an installation location based on a given <ref refid="structentry__ref" kindref="compound">entry_ref</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This method converts the given <ref refid="structentry__ref" kindref="compound">entry_ref</ref> <emphasis>ref</emphasis> to a path and then calls calls <ref refid="classBPathFinder_1a6a97b207ffcc8212c74f994fb6e16f66" kindref="member">BPathFinder::SetTo(const char*, const char*)</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ref</parametername>
</parameternamelist>
<parameterdescription>
<para>A reference to be resolved to a path based on which <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> shall compute the path. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dependency</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the package&apos;s &quot;requires&quot; entry to be used for resolving the installation location. Can be <computeroutput>NULL</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref> <ref refid="classBPathFinder_1a6a97b207ffcc8212c74f994fb6e16f66" kindref="member">BPathFinder::SetTo(const char*, const char*)</ref></para>
</simplesect>
<simplesect kind="return"><para><computeroutput>B_OK</computeroutput> Everything if went fine or an error code otherwise.</para>
</simplesect>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="43" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1a852db3b34c79cbe2e8d2bf2b9d651d53" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::SetTo</definition>
        <argsstring>(const void *codePointer=NULL, const char *dependency=NULL)</argsstring>
        <name>SetTo</name>
        <qualifiedname>BPathFinder::SetTo</qualifiedname>
        <param>
          <type>const void *</type>
          <declname>codePointer</declname>
          <defval><ref refid="SupportDefs_8h_1a070d2ce7b6bb7e5c05602aa8c308d0c4" kindref="member">NULL</ref></defval>
        </param>
        <param>
          <type>const char *</type>
          <declname>dependency</declname>
          <defval><ref refid="SupportDefs_8h_1a070d2ce7b6bb7e5c05602aa8c308d0c4" kindref="member">NULL</ref></defval>
        </param>
        <briefdescription>
<para>Reinitializes the object to refer to an installation location based on a loaded image file. </para>
        </briefdescription>
        <detaileddescription>
<para>When reinitialized with this method a <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> method called afterward determines the path of the image (i.e. executable, library, or add-on) file associated with <emphasis>codePointer</emphasis>, a pointer to a location in the code or static data of an image loaded in the caller&apos;s team. Based on that path the path constant passed to <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> will be evaluated. In most cases that means first determining the path of the installation location from the path.</para>
<para>If <emphasis>dependency</emphasis> is specified, instead of determining the installation location path from the image path, the installation location path of the dependency <emphasis>dependency</emphasis> of the package containing the image file is used.</para>
<para>If the initialization fails, e.g. due to insufficient memory or invalid arguments, this method and subsequent calls to <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> will return an error.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>codePointer</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to code or static data belonging to the image based on which <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> shall compute the path. The special value <computeroutput>B_APP_IMAGE_SYMBOL</computeroutput> (the default) can be used to refer to the program image, and <computeroutput>B_CURRENT_IMAGE_SYMBOL</computeroutput> for the caller&apos;s image. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dependency</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the package&apos;s &quot;requires&quot; entry to be used for resolving the installation location. Can be <computeroutput>NULL</computeroutput> (the default).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A status code. </para>
</simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Everything went fine.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="39" column="9"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classBPathFinder_1a7e0b20cb3f8378a2a7d3763821eb2558" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::FindPaths</definition>
        <argsstring>(const char *architecture, path_base_directory baseDirectory, const char *subPath, uint32 flags, BStringList &amp;_paths)</argsstring>
        <name>FindPaths</name>
        <qualifiedname>BPathFinder::FindPaths</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>architecture</declname>
        </param>
        <param>
          <type><ref refid="FindDirectory_8h_1a8497db5ef25d4ff28530546cefd13232" kindref="member">path_base_directory</ref></type>
          <declname>baseDirectory</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>subPath</declname>
        </param>
        <param>
          <type><ref refid="SupportDefs_8h_1a9a72138d173e1e5243078b8644d4a1c2" kindref="member">uint32</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="classBStringList" kindref="compound">BStringList</ref> &amp;</type>
          <declname>_paths</declname>
        </param>
        <briefdescription>
<para>Retrieves a list of paths in the file system layout. </para>
        </briefdescription>
        <detaileddescription>
<para>For each installation location <ndash/> in the order most specific to most generic, non-packaged before packaged <ndash/> the function evaluates <emphasis>baseDirectory</emphasis> to a path and appends <emphasis>subPath</emphasis>, if given.</para>
<para>If <emphasis>baseDirectory</emphasis> specifies a path that is architecture dependent, <emphasis>architecture</emphasis> is used for constructing each path. If <emphasis>architecture</emphasis> is <computeroutput>NULL</computeroutput>, the caller&apos;s architecture (as returned by <ref refid="Architecture_8h_1a9d717f29f2e0b8d913b8d5be020a8bb3" kindref="member">get_architecture()</ref>) is used.</para>
<para><computeroutput>B_FIND_PATH_PACKAGE_PATH</computeroutput> and <computeroutput>B_FIND_PATH_IMAGE_PATH</computeroutput> are not valid arguments for this function.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>architecture</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the architecture to be used for resolving <emphasis>architecture</emphasis> dependent paths. Can be <computeroutput>NULL</computeroutput>, in which case the caller&apos;s <emphasis>architecture</emphasis> is used. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>baseDirectory</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant indicating which paths to retrieve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>subPath</parametername>
</parameternamelist>
<parameterdescription>
<para>Relative subpath that shall be appended. Can be <computeroutput>NULL</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Bitwise OR of any of the following flags:<itemizedlist>
<listitem><para><computeroutput>B_FIND_PATH_CREATE_DIRECTORY:</computeroutput> If a resulting path doesn&apos;t exist, create it as a directory (including all missing ancestors).</para>
</listitem><listitem><para><computeroutput>B_FIND_PATH_CREATE_PARENT_DIRECTORY:</computeroutput> If a resulting path&apos;s parent doesn&apos;t exist, create the parent directory (including all missing ancestors).</para>
</listitem><listitem><para><computeroutput>B_FIND_PATH_EXISTING_ONLY:</computeroutput> If a resulting path doesn&apos;t exist, skip it. If none of the paths exist, fail with <computeroutput>B_ENTRY_NOT_FOUND</computeroutput>. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_paths</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classBStringList" kindref="compound">BStringList</ref> variable where the retrieved paths shall be stored. The list is emptied before adding the paths. It is also emptied on error.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A status code. </para>
</simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Everything went fine. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_ENTRY_NOT_FOUND</parametername>
</parameternamelist>
<parameterdescription>
<para>A file system entry required for retrieving the paths didn&apos;t exist, e.g. <computeroutput>B_FIND_PATH_EXISTING_ONLY</computeroutput> was specified and none of the resulting paths existed.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="61" column="15"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1ad34869d7e9b0a36a0a324fc5cced8ed0" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::FindPaths</definition>
        <argsstring>(path_base_directory baseDirectory, BStringList &amp;_paths)</argsstring>
        <name>FindPaths</name>
        <qualifiedname>BPathFinder::FindPaths</qualifiedname>
        <param>
          <type><ref refid="FindDirectory_8h_1a8497db5ef25d4ff28530546cefd13232" kindref="member">path_base_directory</ref></type>
          <declname>baseDirectory</declname>
        </param>
        <param>
          <type><ref refid="classBStringList" kindref="compound">BStringList</ref> &amp;</type>
          <declname>_paths</declname>
        </param>
        <briefdescription>
<para>Retrieves a list of paths in the file system layout. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to a call to <ref refid="classBPathFinder_1a7e0b20cb3f8378a2a7d3763821eb2558" kindref="member">BPathFinder::FindPaths(const char*,
path_base_directory, const char*, uint32, BStringList&amp;)</ref> with a <computeroutput>NULL</computeroutput> architecture, 0 flags, and <computeroutput>NULL</computeroutput> subpath.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>baseDirectory</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant indicating which paths to retrieve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_paths</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classBStringList" kindref="compound">BStringList</ref> variable where the retrieved paths shall be stored. The list is emptied before adding the paths. It is also emptied on error.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A status code. </para>
</simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Everything went fine. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_ENTRY_NOT_FOUND</parametername>
</parameternamelist>
<parameterdescription>
<para>A file system entry required for retrieving the paths didn&apos;t exist, e.g. <computeroutput>B_FIND_PATH_EXISTING_ONLY</computeroutput> was specified and none of the resulting paths existed.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="70" column="15"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1aa4aa3e6d65a193f92cd83f303d3f8ac7" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::FindPaths</definition>
        <argsstring>(path_base_directory baseDirectory, const char *subPath, BStringList &amp;_paths)</argsstring>
        <name>FindPaths</name>
        <qualifiedname>BPathFinder::FindPaths</qualifiedname>
        <param>
          <type><ref refid="FindDirectory_8h_1a8497db5ef25d4ff28530546cefd13232" kindref="member">path_base_directory</ref></type>
          <declname>baseDirectory</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>subPath</declname>
        </param>
        <param>
          <type><ref refid="classBStringList" kindref="compound">BStringList</ref> &amp;</type>
          <declname>_paths</declname>
        </param>
        <briefdescription>
<para>Retrieves a list of paths in the file system layout. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to a call to <ref refid="classBPathFinder_1a7e0b20cb3f8378a2a7d3763821eb2558" kindref="member">BPathFinder::FindPaths(const char*,
path_base_directory, const char*, uint32, BStringList&amp;)</ref> with a <computeroutput>NULL</computeroutput> architecture and 0 flags.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>baseDirectory</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant indicating which paths to retrieve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>subPath</parametername>
</parameternamelist>
<parameterdescription>
<para>Relative subpath that shall be appended. Can be <computeroutput>NULL</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_paths</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classBStringList" kindref="compound">BStringList</ref> variable where the retrieved paths shall be stored. The list is emptied before adding the paths. It is also emptied on error.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A status code. </para>
</simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Everything went fine. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_ENTRY_NOT_FOUND</parametername>
</parameternamelist>
<parameterdescription>
<para>A file system entry required for retrieving the paths didn&apos;t exist, e.g. <computeroutput>B_FIND_PATH_EXISTING_ONLY</computeroutput> was specified and none of the resulting paths existed.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="68" column="15"/>
      </memberdef>
      <memberdef kind="function" id="classBPathFinder_1afc36200c68bf618a0d6e6dad99c91e2e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::FindPaths</definition>
        <argsstring>(path_base_directory baseDirectory, const char *subPath, uint32 flags, BStringList &amp;_paths)</argsstring>
        <name>FindPaths</name>
        <qualifiedname>BPathFinder::FindPaths</qualifiedname>
        <param>
          <type><ref refid="FindDirectory_8h_1a8497db5ef25d4ff28530546cefd13232" kindref="member">path_base_directory</ref></type>
          <declname>baseDirectory</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>subPath</declname>
        </param>
        <param>
          <type><ref refid="SupportDefs_8h_1a9a72138d173e1e5243078b8644d4a1c2" kindref="member">uint32</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="classBStringList" kindref="compound">BStringList</ref> &amp;</type>
          <declname>_paths</declname>
        </param>
        <briefdescription>
<para>Retrieves a list of paths in the file system layout. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to a call to <ref refid="classBPathFinder_1a7e0b20cb3f8378a2a7d3763821eb2558" kindref="member">BPathFinder::FindPaths(const char*,
path_base_directory, const char*, uint32, BStringList&amp;)</ref> with a <computeroutput>NULL</computeroutput> architecture.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>baseDirectory</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant indicating which paths to retrieve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>subPath</parametername>
</parameternamelist>
<parameterdescription>
<para>Relative subpath that shall be appended. Can be <computeroutput>NULL</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Bitwise OR of any of the following flags:<itemizedlist>
<listitem><para><computeroutput>B_FIND_PATH_CREATE_DIRECTORY:</computeroutput> If a resulting path doesn&apos;t exist, create it as a directory (including all missing ancestors).</para>
</listitem><listitem><para><computeroutput>B_FIND_PATH_CREATE_PARENT_DIRECTORY:</computeroutput> If a resulting path&apos;s parent doesn&apos;t exist, create the parent directory (including all missing ancestors).</para>
</listitem><listitem><para><computeroutput>B_FIND_PATH_EXISTING_ONLY:</computeroutput> If a resulting path doesn&apos;t exist, skip it. If none of the paths exist, fail with <computeroutput>B_ENTRY_NOT_FOUND</computeroutput>. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_paths</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classBStringList" kindref="compound">BStringList</ref> variable where the retrieved paths shall be stored. The list is emptied before adding the paths. It is also emptied on error.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A status code. </para>
</simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>B_OK</parametername>
</parameternamelist>
<parameterdescription>
<para>Everything went fine. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B_ENTRY_NOT_FOUND</parametername>
</parameternamelist>
<parameterdescription>
<para>A file system entry required for retrieving the paths didn&apos;t exist, e.g. <computeroutput>B_FIND_PATH_EXISTING_ONLY</computeroutput> was specified and none of the resulting paths existed.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="65" column="15"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classBPathFinder_1a9b86de29b3eccc701f282f41b8a87bf8" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="SupportDefs_8h_1ab6735558965995709a53691ae913c81b" kindref="member">status_t</ref></type>
        <definition>status_t BPathFinder::_SetTo</definition>
        <argsstring>(const void *codePointer, const char *path, const char *dependency)</argsstring>
        <name>_SetTo</name>
        <qualifiedname>BPathFinder::_SetTo</qualifiedname>
        <param>
          <type>const void *</type>
          <declname>codePointer</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>path</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>dependency</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="74" column="9"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Helper class to retrieve paths in the file system layout. </para>
    </briefdescription>
    <detaileddescription>
<para>The <ref refid="classBPathFinder" kindref="compound">BPathFinder</ref> provides two sets of methods for retrieving paths: <ref refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" kindref="member">FindPath()</ref> for getting a single path in an installation location specified via a constructor or a <ref refid="classBPathFinder_1a852db3b34c79cbe2e8d2bf2b9d651d53" kindref="member">SetTo()</ref> invocation, and the static <ref refid="classBPathFinder_1a7e0b20cb3f8378a2a7d3763821eb2558" kindref="member">FindPaths()</ref> for getting a list of paths for all installation locations.</para>
<para><simplesect kind="since"><para>Haiku R1 </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="/boot/home/src/haiku/headers/os/storage/PathFinder.h" line="22" column="1" bodyfile="/boot/home/src/haiku/headers/os/storage/PathFinder.h" bodystart="22" bodyend="83"/>
    <listofallmembers>
      <member refid="classBPathFinder_1a9b86de29b3eccc701f282f41b8a87bf8" prot="private" virt="non-virtual"><scope>BPathFinder</scope><name>_SetTo</name></member>
      <member refid="classBPathFinder_1a3c7a42103ed1d0a87c60d488ed3181d2" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>BPathFinder</name></member>
      <member refid="classBPathFinder_1a93c4e093bbe3e99758a8222abf548a5c" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>BPathFinder</name></member>
      <member refid="classBPathFinder_1a24a6178102ad509becb312a467cebb89" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>BPathFinder</name></member>
      <member refid="classBPathFinder_1a5bf296f6e46ac468209dac444f8f114b" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>BPathFinder</name></member>
      <member refid="classBPathFinder_1a2ec3a5dffd3704a705bc7da138b38aed" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>BResolvableExpression</name></member>
      <member refid="classBPathFinder_1ad3e7aacc1a239067bb628dbed1a2352e" prot="private" virt="non-virtual"><scope>BPathFinder</scope><name>fCodePointer</name></member>
      <member refid="classBPathFinder_1a1bb41a7860ccf84754b4cac1476c5789" prot="private" virt="non-virtual"><scope>BPathFinder</scope><name>fDependency</name></member>
      <member refid="classBPathFinder_1a6430c47700b38075404d427f48b37868" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>FindPath</name></member>
      <member refid="classBPathFinder_1aae646784db3ec1c29844b6312d857250" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>FindPath</name></member>
      <member refid="classBPathFinder_1a9e0e6558f8070334dc56632bac6058ca" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>FindPath</name></member>
      <member refid="classBPathFinder_1a769fed5369dfe5ca73cc14dc321afef1" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>FindPath</name></member>
      <member refid="classBPathFinder_1a7e0b20cb3f8378a2a7d3763821eb2558" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>FindPaths</name></member>
      <member refid="classBPathFinder_1afc36200c68bf618a0d6e6dad99c91e2e" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>FindPaths</name></member>
      <member refid="classBPathFinder_1aa4aa3e6d65a193f92cd83f303d3f8ac7" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>FindPaths</name></member>
      <member refid="classBPathFinder_1ad34869d7e9b0a36a0a324fc5cced8ed0" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>FindPaths</name></member>
      <member refid="classBPathFinder_1a2dba2c2bf12e2a5635468e20b08234f5" prot="private" virt="non-virtual"><scope>BPathFinder</scope><name>fInitStatus</name></member>
      <member refid="classBPathFinder_1a33e34df330188116fe14e025aa07aa3e" prot="private" virt="non-virtual"><scope>BPathFinder</scope><name>fPath</name></member>
      <member refid="classBPathFinder_1a6f3d1ca7745a70031ca1d5ad14edf8c9" prot="private" virt="non-virtual"><scope>BPathFinder</scope><name>fReserved</name></member>
      <member refid="classBPathFinder_1a852db3b34c79cbe2e8d2bf2b9d651d53" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>SetTo</name></member>
      <member refid="classBPathFinder_1a6a97b207ffcc8212c74f994fb6e16f66" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>SetTo</name></member>
      <member refid="classBPathFinder_1afa658250375811e03bf8a53094bd9422" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>SetTo</name></member>
      <member refid="classBPathFinder_1af6afaf9aae2355b57978e660338bd642" prot="public" virt="non-virtual"><scope>BPathFinder</scope><name>SetTo</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
